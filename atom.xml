<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oYo-Byte</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://byte-cloris.com/"/>
  <updated>2018-08-06T06:31:26.351Z</updated>
  <id>http://byte-cloris.com/</id>
  
  <author>
    <name>oYo-Byte</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习PostgreSQL的查询机制</title>
    <link href="http://byte-cloris.com/2018/08/03/learn_about_pg_query_processing/"/>
    <id>http://byte-cloris.com/2018/08/03/learn_about_pg_query_processing/</id>
    <published>2018-08-03T10:10:45.600Z</published>
    <updated>2018-08-06T06:31:26.351Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习PostgreSQL的FDW</title>
    <link href="http://byte-cloris.com/2018/08/03/learn_about_pgfdw/"/>
    <id>http://byte-cloris.com/2018/08/03/learn_about_pgfdw/</id>
    <published>2018-08-03T07:52:42.563Z</published>
    <updated>2018-08-06T09:33:43.003Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个FDW的核心是实现一组回调函数，有了这些回调函数的帮助, 在查询外部表对象的执行过程中就可以将运行逻辑切换至自定义的扩展代码中, 进而遵照PG的内部机制实现对外部数据源的访问。</p><p>目前PostgreSQL11 beta2，提供的FDW回调函数接口有39个。FDW的实现者需要根据外部数据源自身的能力（比如是否支持写操作，以及是否支持在外部数据源端执行join操作等等）对这些接口有选择地予以实现。</p><p>这些接口中, 最核心的接口有7个。无论外部数据源自身能力如何, 这7个接口是实现通过外部表对象访问该数据源的必须接口。它们的接口定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GetForeignRelSize_function)</span> <span class="params">(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GetForeignPaths_function)</span> <span class="params">(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ForeignScan *(*GetForeignPlan_function) (PlannerInfo *root, RelOptInfo *baserel,Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*BeginForeignScan_function)</span> <span class="params">(ForeignScanState *node, <span class="keyword">int</span> eflags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> TupleTableSlot *(*IterateForeignScan_function) (ForeignScanState *node);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ReScanForeignScan_function)</span> <span class="params">(ForeignScanState *node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EndForeignScan_function)</span> <span class="params">(ForeignScanState *node)</span></span>;</span><br></pre></td></tr></table></figure><p>在PG中，查询语句经过以下5个子系统处理：</p><ol><li><p>Parser<br>用于将文本式的SQL命令转换成解析树</p></li><li><p>Analyzer/Analyser<br>用于执行解析树的语义分析并生成查询树</p></li><li>Rewriter<br>重写器用于根据规则系统中已存在的规则转换查询树</li><li>Planner<br>规划器生成可以从查询树中最有效地执行的计划树</li><li>Executor<br>执行器通过按计划树创建的顺序访问表和索引来执行查询</li></ol><p><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180806173200.png" alt=""></p><p>可以整合成三个大阶段：  </p><ul><li>Parser: 包含对SQL的语法解析，语义校验，查询重写</li><li>Optimizer：生成查询计划</li><li>Executor：按照火山模型执行查询计划的算子并向上返回数据</li></ul><p>PG的FDW所需的7个回调函数主要是在Optimizer和Executor阶段进行“介入”:<br><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180806173225.png" alt=""></p><p>这7个回调函数详细的调用时间以及作用：</p><table><thead><tr><th style="text-align:left">回调函数</th><th style="text-align:left">在PG中的调用时机</th><th style="text-align:left">作用</th><th>详细描述</th></tr></thead><tbody><tr><td style="text-align:left">GetForeignRelSize</td><td style="text-align:left">优化器生成访问路径的过程中对外部表估算访问代价时</td><td style="text-align:left">提供外部表对于计算访问代价所需的基础数据，如表的元组数以及元组的平均长度,并将这些数据保存在输入参数baserel的字段”rows”以及”width”中</td><td><code>void GetForeignRelSize (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);</code>  <br>root是规划器的关于该查询的全局信息；baserel是规划器的关于该表的信息；foreigntableid是外部表在pg_class中的 OID （foreigntableid可以从规划器的数据结构中获得，但是为了减少工作量，这里直接显式地将它传递给函数）；<br>这个函数应该更新baserel-&gt;rows为表扫描根据限制条件完成了过滤后将返回的预期行数。baserel-&gt;rows的初始值只是一个常数的默认估计值，应该尽可能把它替换掉。如果该函数能够计算出一个平均结果行宽度的更好的估计值，该函数也可能选择更新baserel-&gt;width。</td></tr><tr><td style="text-align:left">GetForeignPaths</td><td style="text-align:left">生成对外部表的访问路径时</td><td style="text-align:left">生成对目标外部表的访问路径(通过PG中的接口createforeignscanpath()生成)</td><td><code>void GetForeignPaths (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);</code><br>参数和GetForeignRelSize相同；<br>这个函数必须为外部表上的扫描生成至少一个访问路径（ForeignPath节点），并且必须调用add_path把每一个这样的路径加入到baserel-&gt;pathlist中。我们推荐使用create_foreignscan_path来建立ForeignPath节点。该函数可以生成多个访问路径，例如一个具有合法pathkeys的路径表示一个预排序好的结果。每一个访问路径必须包含代价估计，并且能包含任何FDW的私有信息，这种信息被用来标识想要使用的指定扫描方法。</td></tr><tr><td style="text-align:left">GetForeignPlan</td><td style="text-align:left">优化器生成扫描外部表的查询计划节点时</td><td style="text-align:left">生成访问目标外部表的ForeignScan计划节点(通过PG中的接口make_foreignscan())</td><td><code>ForeignScan * GetForeignPlan (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan);</code><br>参数和GetForeignRelSize的一样，外加选中的ForeignPath（在前面由GetForeignPaths、GetForeignJoinPaths或者GetForeignUpperPaths产生）、被计划节点发出的目标列表以及计划节点强制的限制子句以及被RecheckForeignScan执行的复查所使用的ForeignScan的外子计划（如果该路径是用于一个连接而非基本关系，则foreigntableid是InvalidOid）；<br>这个函数必须创建并返回一个ForeignScan计划节点，推荐使用make_foreignscan来建立ForeignScan节点。</td></tr><tr><td style="text-align:left">BeginForeignScan</td><td style="text-align:left">执行器即将开始执行ForeignScan算子，进行该算子相关的初始化时</td><td style="text-align:left">获取执行ForeignScan算子所需的信息，并将它们组织并保存在ForeignScanState中</td><td><code>void BeginForeignScan (ForeignScanState *node, int eflags);</code><br>它应该执行任何在扫描能够开始之前需要完成的初始化工作，但是并不开始执行真正的扫描（会在第一次调用IterateForeignScan时完成）。ForeignScanState节点已经被创建好了，但是它的fdw_state属性仍然为 NULL。关于要被扫描的表的信息可以通过ForeignScanState节点访问（特殊地，从底层的ForeignScan计划节点，它包含任何由GetForeignPlan提供的FDW私有信息）。eflags包含描述执行器对该计划节点操作模式的标志位。<br>注意当(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)为真时，这个函数不应该执行任何外部可见的动作；它应当只做最少的事情来创建对ExplainForeignScan 和EndForeignScan有效的节点状态</td></tr><tr><td style="text-align:left">IterateForeignScan</td><td style="text-align:left">执行ForeignScan算子过程中需要获取下一元组时</td><td style="text-align:left">读取外部数据源的一行数据，并将它组织为PG中的Tuple(即TupleTableSlot). 当该回调函数返回一个空的TupleTableSlot结构时, 迭代器停止迭代</td><td><code>TupleTableSlot * IterateForeignScan (ForeignScanState *node);</code><br>从外部源获得一行，将它放在一个元组表槽中返回（节点的ScanTupleSlot应当被用于此目的）。如果没有更多的行可用则返回 NULL。元组表槽设施允许一个物理的或者虚拟的元组被返回；在大部分情况下出于性能的考虑会倾向于选择后者。注意这是在一个短期存在的内存上下文中被调用的，该内存上下文会在调用之间被重置。如果需要长期存在的存储，需要在BeginForeignScan中创建内存上下文，或者使用节点的EState中的es_query_cxt。<br>如果提供了fdw_scan_tlist目标列表，被返回的行必须匹配它，如果没有提供则它们必须匹配被扫描的外部表的行类型。如果选择优化掉不需要的列，你应该在那些列的位置上插入控制或者生成一个忽略了那些列的fdw_scan_tlist列表。<br>注意PostgreSQL的执行器并不在乎被返回的行是否违背了定义在该外部表上的任何约束 — 但是规划器会在乎这一点，并且如果在外部表中有可见行不满足一个约束，规划器可能会错误地优化查询。如果当用户已经声明一个约束应该为真时它却被违背，最合适的处理可能是产生一个错误（就像在数据类型失配的情况下所作的那样）</td></tr><tr><td style="text-align:left">ReScanForeignScan</td><td style="text-align:left">执行Nested Loop过程中需要重置Inner Scan时(即Outter Scan需要向前推进一行时)</td><td style="text-align:left">将外部数据源的读取位置重置回最初的起始位置</td><td><code>void ReScanForeignScan (ForeignScanState *node);</code><br>注意扫描所依赖的任何参数可能已经改变了值，因此新扫描不一定会返回完全相同的行。</td></tr><tr><td style="text-align:left">EndForeignScan</td><td style="text-align:left">ForeignScan算子执行完成时</td><td style="text-align:left">释放整个ForeignScan算子执行过程中占用的外部资源或FDW中的资源</td><td><code>void EndForeignScan (ForeignScanState *node);</code><br>通常释放palloc过的内存并不重要，但是打开的文件和到远程服务器的连接等应该被清理。</td></tr></tbody></table><p>以上是必须实现的扫描相关的回调函数</p><p><br><br><br></p><p>参考：</p><p><a href="https://xiaowing.github.io/post/20180513_write_pgfdw_in_golang_part02/" target="_blank" rel="noopener">https://xiaowing.github.io/post/20180513_write_pgfdw_in_golang_part02/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现一个FDW的核心是实现一组回调函数，有了这些回调函数的帮助, 在查询外部表对象的执行过程中就可以将运行逻辑切换至自定义的扩展代码中, 进而遵照PG的内部机制实现对外部数据源的访问。&lt;/p&gt;
&lt;p&gt;目前PostgreSQL11 beta2，提供的FDW回调函数接口有39个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解读C语言声明</title>
    <link href="http://byte-cloris.com/2018/07/26/%E8%A7%A3%E8%AF%BBC%E8%AF%AD%E8%A8%80%E5%A3%B0%E6%98%8E/"/>
    <id>http://byte-cloris.com/2018/07/26/解读C语言声明/</id>
    <published>2018-07-26T03:18:23.922Z</published>
    <updated>2018-08-02T16:51:28.267Z</updated>
    
    <content type="html"><![CDATA[<p>C语言所有复杂的指针声明，都是由各种声明嵌套构成的。如何解读复杂指针声明呢？</p><p>右左法则（既著名又常用的方法 ）</p><p>右左法则英文原文：</p><blockquote><p>The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed.</p></blockquote><p>翻译如下：</p><p>右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。</p><p>这时就会有个疑惑：怎样判断那个括号是最里面的呢？</p><p>因此需要对这个法则进行修改，结合《C专家编程》里提到的分析方法，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。</p><p>分析C语言的声明步骤：</p><ul><li>第1步：从左至右，找到第一个未定义的标识符。</li><li>第2步：查看标识符右边的符号，并确定是一个数组还是函数。</li><li>第3步：查看左边的符号。</li><li>第3步a：如果是左括号则将处理过的部分结合到一起直到遇到右括号作为标识符返回第2步。</li><li>第3步b：如果是<code>const</code>，<code>volatile</code>，<code>*</code>其中之一则继续向左直到不是这三个符号之一。</li><li>第4步：剩下的符号构成声明的基本类型。</li></ul><p>感觉还是有点晕？</p><p>结合例子说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*(*x[<span class="number">3</span>])())[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li>第1步：从左到右找到第一个标识符x。</li><li>第2步：查看标识符右边的符号是<code>[</code>，说明x是一个具有3个元素的数组。</li><li>第3步：查看左边的符号是<code>*</code>，转至第3步b。</li><li>第3步b：说明数组中的元素都是指针，向左就是左括号了，将这个左括号结合到对应的右括号（也就是<code>(*x[3])</code>）作为新的标识符返回第2步 。</li><li>第2步：查看右边的符号是<code>(</code>，说明指针是指向参数列表为空的函数的指针。</li><li>查看左边的符号，是<code>*</code>, 转至第3步b。</li><li>说明函数的返回值是指针，向左是左括号，将这个左括号结合到对应的右括号（也就是<code>(*(*x[3])())</code>）作为新的标识符返回第2步。</li><li>第2步：查看右边的符号是<code>[</code>，所以是指向具有五个元素的数组的指针。</li><li>第3步：查看左边的括号，既不是a情况，也不是b情况，跳至第4步。</li><li>第4步：数组的类型为char。</li></ul><p>所以以上的声明表示的是x是一个具有3个元素的数组，数组的每个元素都是一个指向函数的指针，函数的参数列表为空，返回值是指向一个具有5个元素的指针，元素的类型为char。</p><p>来个程序验证一下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">func()&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">5</span>] = &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> (*(*x[<span class="number">3</span>])())[<span class="number">5</span>]; <span class="comment">// x是一个长度为3的数组，元素是一个函数指针，函数的返回值是指向一个长度为5的char型数组指针。</span></span><br><span class="line"></span><br><span class="line">    x[<span class="number">0</span>] = &amp;func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x的总长度：%d \n"</span>,<span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x元素的长度：%d \n"</span>,<span class="keyword">sizeof</span>(x[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"函数指针的长度：%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x的元素个数：%d \n"</span>,<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(x[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> (*c)[<span class="number">5</span>] = (x[<span class="number">0</span>])();<span class="comment">//c是一个指向长度为5的char型数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c的总长度：%d \n"</span>,<span class="keyword">sizeof</span>(*c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c元素的长度：%d \n"</span>,<span class="keyword">sizeof</span>((*c)[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char型的长度：%d \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c的第4个元素是：%c \n"</span>,(*c)[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"整体调用，第4个元素是：%c \n"</span>,(*(x[<span class="number">0</span>])())[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x的总长度：24</span><br><span class="line">x元素的长度：8</span><br><span class="line">函数指针的长度：8</span><br><span class="line">x的元素个数：3</span><br><span class="line">c的总长度：5</span><br><span class="line">c元素的长度：1</span><br><span class="line">chart性的长度：1</span><br><span class="line">c的第4个元素是：4</span><br><span class="line">整体调用，结果的第4个元素是：4</span><br></pre></td></tr></table></figure></p><p>Try:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">char</span> *(*c[<span class="number">10</span>])(<span class="keyword">int</span> **p)</span><br></pre></td></tr></table></figure><p><br></p><p><br></p><p>Clockwise/Spiral Rule（顺时针/螺旋法则）</p><p>三步：</p><ol><li><p>从未定义标识符开始，以顺时针方向移动，当遇到以下元素时，用相应的语言陈述替换它们：</p><p>​    <code>[X]</code> or <code>[]</code> =&gt;  Array X size of… or Array undefined size of…</p><p>​    <code>(type1, type2)</code> =&gt; function passing type1 and type2 returning…</p><p>​    <code>*</code> =&gt;  pointer(s) to…</p></li><li><p>继续以上步骤，直至覆盖所有的字符。</p></li><li><p>首先解决括号中的内容。</p></li></ol><p>例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     +-------+</span><br><span class="line">     | +-+   |</span><br><span class="line">     | ^ |   |</span><br><span class="line"><span class="keyword">char</span> *str[<span class="number">10</span>];</span><br><span class="line"> ^   ^   |   |</span><br><span class="line"> |   +---+   |</span><br><span class="line"> +-----------+</span><br></pre></td></tr></table></figure><ul><li><p>str是什么？</p><p>“str是一个……</p></li><li><p>从str开始以顺时针方向移动，遇到<code>[</code>，这意味着是一个数组</p><p>“str是一个长度为10的数组，元素是……</p></li><li><p>继续移动，遇到<code>*</code>,说明是指针</p><p>“str是一个长度为10的数组，元素是指向……的指针</p></li><li><p>继续遇到了<code>;</code>，然后继续移动，遇到<code>char</code></p><p>“str是一个长度为10的数组，元素是指向char的指针”</p></li><li><p>遍历完所有字符，解析完毕</p></li></ul><p>以上的<code>char (*(*x[3])())[5];</code>亦可这样去处理<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      +----------+</span><br><span class="line">      | +-----+  |</span><br><span class="line">      | |++   |  |</span><br><span class="line">      | |^|   |  |</span><br><span class="line"><span class="keyword">char</span> (*(*x[<span class="number">3</span>])())[<span class="number">5</span>];</span><br><span class="line"> ^    ^ ^ |   |  |</span><br><span class="line"> |    | +-+   |  |</span><br><span class="line"> |    +-------+  |</span><br><span class="line"> +---------------+</span><br></pre></td></tr></table></figure></p><ul><li>x是什么？<br>“x是一个……</li><li>从x开始以顺时针方向移动，遇到<code>[</code>，这意味着是一个数组<br>“x是一个长度为3的数组，元素是……</li><li>继续移动，遇到<code>*</code>,说明是指针<br>“x是一个长度为3的数组，元素是指向……的指针</li><li>继续遇到<code>(</code>,说明是函数<br>“x是一个长度为3的数组，元素是指向函数的指针，函数是……</li><li>继续遇到<code>*</code>，说明是指针<br>“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向……的指针</li><li>继续遇到<code>[</code>，说明是数组<br>“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向长度为5的……类型元素的数组的指针</li><li>继续遇到<code>char</code>,说明元素是char型<br>“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向长度为5的char类型元素的数组的指针”</li><li>遍历完毕</li></ul><p>Try:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>  <span class="keyword">char</span> *(*fp)( <span class="keyword">int</span>, <span class="keyword">float</span> *);</span><br><span class="line"><span class="number">3.</span>  <span class="keyword">void</span> (*signal(<span class="keyword">int</span>, <span class="keyword">void</span> (*fp)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p> <br> <br> <br> <br> <br> <br> <br> <br></p><p>Answer：</p><ol><li>c是一个具有10个元素的数组，数组的元素都是函数指针，其所指向的函数是接受一个指向整型指针的指针，返回值是指向char的指针。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     +-----------------+</span><br><span class="line">     | +------+     +-+|</span><br><span class="line">     | |++    |     |++|</span><br><span class="line">     | |^|    |     |^||</span><br><span class="line"><span class="keyword">char</span> *(*c[<span class="number">10</span>])(<span class="keyword">int</span> **p);</span><br><span class="line">  ^  ^ ^ |    |    ^^ ||</span><br><span class="line">  |  | +-+    |    |+-+|</span><br><span class="line">  |  +--------+    +--+|</span><br><span class="line">  +--------------------+</span><br></pre></td></tr></table></figure><ol start="2"><li>fp是一个函数指针，该函数接受一个整型和一个浮点型指针入参，返回值是指向char的指针。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     +--------------------+</span><br><span class="line">     | +---+              |</span><br><span class="line">     | |+-+|              |</span><br><span class="line">     | |^ ||              |</span><br><span class="line"><span class="keyword">char</span> *(*fp)( <span class="keyword">int</span>, <span class="keyword">float</span> *);</span><br><span class="line"> ^   ^ ^  ||              |</span><br><span class="line"> |   | +--+|              |</span><br><span class="line"> |   +-----+              |</span><br><span class="line"> +------------------------+</span><br></pre></td></tr></table></figure><ol start="3"><li>signal是一个函数，该函数值一个接受一个整型和一个函数指针（该函数是入参是整型，返回值为空void），返回值是指向一个入参是整型，返回值是空void的函数指针。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      +-----------------------------+</span><br><span class="line">      |                  +---+      |</span><br><span class="line">      |  +---+           |+-+|      |</span><br><span class="line">      |  ^   |           |^ ||      |</span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span>, <span class="keyword">void</span> (*fp)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"> ^    ^      |      ^    ^  ||      |</span><br><span class="line"> |    +------+      |    +--+|      |</span><br><span class="line"> |                  +--------+      |</span><br><span class="line"> +----------------------------------+</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>参考：</p><p><a href="https://blog.csdn.net/wangweixaut061/article/details/6549768" target="_blank" rel="noopener">C语言复杂声明解析</a></p><p><a href="https://blog.csdn.net/jixuxjixu3/article/details/5824431" target="_blank" rel="noopener">c语言声明的分析方法</a></p><p><a href="http://c-faq.com/decl/spiral.anderson.html" target="_blank" rel="noopener">The Clockwise/Spiral Rule</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言所有复杂的指针声明，都是由各种声明嵌套构成的。如何解读复杂指针声明呢？&lt;/p&gt;
&lt;p&gt;右左法则（既著名又常用的方法 ）&lt;/p&gt;
&lt;p&gt;右左法则英文原文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The right-left rule: Start reading th
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL使用oracle_fdw与Oracle查询性能对比</title>
    <link href="http://byte-cloris.com/2018/07/25/PostgreSQL%E4%BD%BF%E7%94%A8oracle_fdw%E4%B8%8EOracle%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://byte-cloris.com/2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/</id>
    <published>2018-07-25T03:29:52.892Z</published>
    <updated>2018-08-02T07:00:33.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在PostgreSQL中使用oracle-fdw"><a href="#在PostgreSQL中使用oracle-fdw" class="headerlink" title="在PostgreSQL中使用oracle_fdw"></a>在PostgreSQL中使用oracle_fdw</h3><h4 id="安装oracle-fdw插件"><a href="#安装oracle-fdw插件" class="headerlink" title="安装oracle_fdw插件"></a>安装oracle_fdw插件</h4><ol><li>安装前要求：</li></ol><ul><li>全部功能要求PostgreSQL9.3及以上</li><li>Oracle client要求10.1以上</li><li>确保PostgreSQL配置了<code>--without-ldap</code></li><li>确保<code>pg_config</code>在PATH中(用 <code>pg_config --pgxs</code>测试)</li><li>设置了ORACLE_HOME环境变量</li></ul><p><a href="https://github.com/laurenz/oracle_fdw" target="_blank" rel="noopener">下载oracle_fdw源代码</a>,<br>并解压到某个目录下，进入文件目录，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> make</span><br><span class="line"><span class="meta">$</span> make install</span><br></pre></td></tr></table></figure><p>安装完毕后，使用psql连接到PostgreSQL；<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> psql -d testdb;</span><br></pre></td></tr></table></figure></p><p>使用PostgreSQL的超级用户配置oralce_fdw:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testdb=# create extension oracle_fdw;</span><br><span class="line">testdb=# create server oracle_121_56 foreign data wrapper oracle_fdw options (dbserver '//192.168.121.56:1521/orcl');</span><br><span class="line">testdb=# create user mapping for public server oracle_121_56 options (user 'dbuser' password 'test');</span><br></pre></td></tr></table></figure><h3 id="简单查询，无索引"><a href="#简单查询，无索引" class="headerlink" title="简单查询，无索引"></a>简单查询，无索引</h3><p>生成测试数据，创建一个表，并同时添加1百万条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_table <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span>,to_char(<span class="keyword">sysdate</span> + <span class="keyword">rownum</span>/<span class="number">24</span>/<span class="number">3600</span>, <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">as</span> inc_datetime,trunc(dbms_random.value(<span class="number">0</span>, <span class="number">100</span>)) <span class="keyword">as</span> random_id,dbms_random.string(<span class="string">'x'</span>, <span class="number">20</span>) random_string <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt;= <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p>创建完表后，在原来表的基础上追加记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_table (<span class="keyword">ID</span>, INC_DATETIME,RANDOM_ID,RANDOM_STRING) <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span>,  to_char(<span class="keyword">sysdate</span> + <span class="keyword">rownum</span>, <span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">as</span> inc_datetime,trunc(dbms_random.value(<span class="number">0</span>, <span class="number">100</span>)) <span class="keyword">as</span> random_id, dbms_random.string(<span class="string">'x'</span>, <span class="number">20</span>) random_string  <span class="keyword">from</span> dual  <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt;= <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p><p>上面SQL是利用了Oracle数据库语法的几个实用小技巧实现的:</p><ol><li><p>利用Oracle特有的“connect by”树形连接语法生成测试记录，“level &lt;= 10”表示要生成10记录；</p></li><li><p>利用rownum虚拟列生成递增的整数数据；</p></li><li><p>利用sysdate函数加一些简单运算来生成日期数据，本例中是每条记录的时间加1秒；</p></li><li><p>利用dbms_random.value函数生成随机的数值型数据，本例中是生成0到100之间的随机整数；</p></li><li><p>利用dbms_random.string函数生成随机的字符型数据，本例中是生成长度为20的随机字符串，字符串中可以包括字符或数字。</p></li><li><p>to_char(sysdate + rownum, ‘yyyy-mm-dd hh24:mi:ss’) 这里是转换为字符串，如果该字段的类型为TimeStamp时间戳，那这里可以改写一下方法，转换为时间戳 to_timestamp(sysdate + rownum, ‘yyyy-mm-dd hh24:mi:ss’)</p></li></ol><p>PostgreSQL 创建相应的外部表</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testdb=# create foreign table test_table(id int, inc_datetime varchar(19), random_id int, random_string varchar(4000)) server oracle_121_56 options (schema 'DBUSER', table 'TEST_TABLE');</span><br></pre></td></tr></table></figure><ol><li>查询表的行数</li></ol><ul><li>sqlplus</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sqlplus dbuser/test@//192.168.121.56:1521/orcl</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select count(*) from test_table;</span><br><span class="line"> COUNT(*)</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">2000000</span><br><span class="line">Elapsed: 00:00:00.13</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select count(*) from test_table;</span><br><span class="line">count</span><br><span class="line"><span class="comment">---------</span></span><br><span class="line">2000000</span><br><span class="line">(1 row)</span><br><span class="line">Time: 5264.299 ms (00:05.264)</span><br></pre></td></tr></table></figure><p>查看oracle session中真正执行的sql语句，红框为oracle_fdw执行时，oracle session中执行的sql：<br><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180731143023.png" alt=""></p><p>在psql中查看<code>select count(*) from test_table;</code>的执行计划：<br><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180731143351.png" alt=""></p><p>可见oracle处理的sql即是查询计划中的oracle query后面的sql</p><p>查看网络流量<br><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180731114417.png" alt=""><br>oracle_fdw的网络流量明显比sqlplus要高出很多。</p><ol start="2"><li>查询某条记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table where id= 50;</span><br><span class="line"></span><br><span class="line">ID  INC_DATETIME   RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">-------- -------------------- ------------ -----------------------------</span></span><br><span class="line">50  2018-07-25 01:13:38       212VMPGE0K6Y293T9WRT7G</span><br><span class="line">50  2018-09-13 01:49:31       51RGUV1BJJNSTNXDMXMVRL</span><br><span class="line">Elapsed: 00:00:00.05</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table where id= 50;</span><br><span class="line"> id |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">----+---------------------+-----------+----------------------</span></span><br><span class="line"> 50 | 2018-07-25 01:13:38 |        21 | 2VMPGE0K6Y293T9WRT7G</span><br><span class="line"> 50 | 2018-09-13 01:49:31 |        51 | RGUV1BJJNSTNXDMXMVRL</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">Time: 56.811 ms</span><br></pre></td></tr></table></figure><ol start="3"><li>使用orderby id获取前5行记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table order by id offset 0 rows fetch next 5 rows only;</span><br><span class="line"></span><br><span class="line">ID  INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">-------- ------------------- ---------- ----------------------</span></span><br><span class="line"> 1  2018-07-25 01:12:49       175SPF1INUG6S2L1ZSTU7R</span><br><span class="line"> 1  2018-07-26 01:49:31       63BIO3ZOV104VLNKZWGDZN</span><br><span class="line"> 2  2018-07-25 01:12:50       95HJFAWH9L7SF85YSPNDHV</span><br><span class="line"> 2  2018-07-27 01:49:31       862PNXP02ZYWYYUZQFWVVN</span><br><span class="line"> 3  2018-07-25 01:12:51       86T3UQBBMP3O02LGO6ONPF</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.32</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table order by id offset 0 rows fetch next 5 rows only;</span><br><span class="line"> id |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">----+---------------------+-----------+----------------------</span></span><br><span class="line">  1 | 2018-07-25 01:12:49 |        17 | 5SPF1INUG6S2L1ZSTU7R</span><br><span class="line">  1 | 2018-07-26 01:49:31 |        63 | BIO3ZOV104VLNKZWGDZN</span><br><span class="line">  2 | 2018-07-27 01:49:31 |        86 | 2PNXP02ZYWYYUZQFWVVN</span><br><span class="line">  2 | 2018-07-25 01:12:50 |        95 | HJFAWH9L7SF85YSPNDHV</span><br><span class="line">  3 | 2018-07-25 01:12:51 |        86 | T3UQBBMP3O02LGO6ONPF</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">Time: 1169.874 ms (00:01.170)</span><br></pre></td></tr></table></figure><ol start="4"><li>使用orderby random_string获取前5行记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_table <span class="keyword">order</span> <span class="keyword">by</span> random_string <span class="keyword">offset</span> <span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">only</span>;</span><br><span class="line"></span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- --------------------------------</span></span><br><span class="line">    938145 2018-08-04 21:48:33       8600008E7XPHROOHEPUYRC</span><br><span class="line">    686337 2018-08-01 23:51:45       3100008JW9S5PXE19F4W4M</span><br><span class="line">     19954 2073-03-12 01:49:31       690000G3A2KNDLVN61WOSH</span><br><span class="line">    382404 3065-07-20 01:49:31       410000JDLZP2J8VZFOJ44J</span><br><span class="line">    234567 2660-10-14 01:49:31       78000142EWU0B3GMIPA2AL</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.33</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table order by random_string offset 0 rows fetch next 5 rows only;</span><br><span class="line">   id   |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">--------+---------------------+-----------+----------------------</span></span><br><span class="line"> 938145 | 2018-08-04 21:48:33 |        86 | 00008E7XPHROOHEPUYRC</span><br><span class="line"> 686337 | 2018-08-01 23:51:45 |        31 | 00008JW9S5PXE19F4W4M</span><br><span class="line">  19954 | 2073-03-12 01:49:31 |        69 | 0000G3A2KNDLVN61WOSH</span><br><span class="line"> 382404 | 3065-07-20 01:49:31 |        41 | 0000JDLZP2J8VZFOJ44J</span><br><span class="line"> 234567 | 2660-10-14 01:49:31 |        78 | 000142EWU0B3GMIPA2AL</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">Time: 13275.162 ms (00:13.275)</span><br></pre></td></tr></table></figure><p>oracle_fdw执行时,oracle session中执行的sql</p><p><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180731145032.png" alt=""></p><p>psql中查看执行计划<br><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180731145127.png" alt=""></p><p>网络流量对比<br><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180731144752.png" alt=""></p><h3 id="简单查询，带索引"><a href="#简单查询，带索引" class="headerlink" title="简单查询，带索引"></a>简单查询，带索引</h3><p>创建id索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> test_id <span class="keyword">on</span> test_table(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><ol><li>查询某条记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table where id = 8222;</span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- -----------------------------</span></span><br><span class="line">      8222 2018-07-25 03:29:50       680VJJSTBAN6RAINSTWQAB</span><br><span class="line">      8222 2041-01-27 01:49:31       423SAYJV50LNDHURP5FU0K</span><br><span class="line">Elapsed: 00:00:00.07</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table where id = 8222;</span><br><span class="line">  id  |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">------+---------------------+-----------+----------------------</span></span><br><span class="line"> 8222 | 2018-07-25 03:29:50 |        68 | 0VJJSTBAN6RAINSTWQAB</span><br><span class="line"> 8222 | 2041-01-27 01:49:31 |        42 | 3SAYJV50LNDHURP5FU0K</span><br><span class="line">(2 rows)</span><br><span class="line">Time: 6.565 ms</span><br></pre></td></tr></table></figure><ol start="2"><li>使用orderby id获取前5行记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table order by id offset 0 rows fetch next 5 rows only;</span><br><span class="line"></span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- ----------------------------</span></span><br><span class="line"> 1 2018-07-25 01:12:49       175SPF1INUG6S2L1ZSTU7R</span><br><span class="line"> 1 2018-07-26 01:49:31       63BIO3ZOV104VLNKZWGDZN</span><br><span class="line"> 2 2018-07-25 01:12:50       95HJFAWH9L7SF85YSPNDHV</span><br><span class="line"> 2 2018-07-27 01:49:31       862PNXP02ZYWYYUZQFWVVN</span><br><span class="line"> 3 2018-07-25 01:12:51       86T3UQBBMP3O02LGO6ONPF</span><br><span class="line">Elapsed: 00:00:00.33</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table order by id offset 0 rows fetch next 5 rows only;</span><br><span class="line"> id |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">----+---------------------+-----------+----------------------</span></span><br><span class="line">  1 | 2018-07-25 01:12:49 |        17 | 5SPF1INUG6S2L1ZSTU7R</span><br><span class="line">  1 | 2018-07-26 01:49:31 |        63 | BIO3ZOV104VLNKZWGDZN</span><br><span class="line">  2 | 2018-07-27 01:49:31 |        86 | 2PNXP02ZYWYYUZQFWVVN</span><br><span class="line">  2 | 2018-07-25 01:12:50 |        95 | HJFAWH9L7SF85YSPNDHV</span><br><span class="line">  3 | 2018-07-25 01:12:51 |        86 | T3UQBBMP3O02LGO6ONPF</span><br><span class="line">(5 rows)</span><br><span class="line">Time: 1345.988 ms (00:01.346)</span><br></pre></td></tr></table></figure><p>创建random_string索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> test_string <span class="keyword">on</span> test_table(random_string);</span><br></pre></td></tr></table></figure><ol><li>查询某条记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table where random_string='GMX0VD9WY4YPN8T4XDML';</span><br><span class="line"></span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- -------------------------------</span></span><br><span class="line">       871 2018-07-25 01:27:19       45GMX0VD9WY4YPN8T4XDML</span><br><span class="line">Elapsed: 00:00:00.01</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table where random_string='GMX0VD9WY4YPN8T4XDML';</span><br><span class="line"> id  |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">-----+---------------------+-----------+----------------------</span></span><br><span class="line"> 871 | 2018-07-25 01:27:19 |        45 | GMX0VD9WY4YPN8T4XDML</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 118.376 ms</span><br></pre></td></tr></table></figure><ol start="2"><li>使用order by random_string获取前5条记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table order by random_string offset 0 rows fetch next 5 rows only;</span><br><span class="line"></span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- ----------------------------------</span></span><br><span class="line">    938145 2018-08-04 21:48:33       8600008E7XPHROOHEPUYRC</span><br><span class="line">    686337 2018-08-01 23:51:45       3100008JW9S5PXE19F4W4M</span><br><span class="line">     19954 2073-03-12 01:49:31       690000G3A2KNDLVN61WOSH</span><br><span class="line">    382404 3065-07-20 01:49:31       410000JDLZP2J8VZFOJ44J</span><br><span class="line">    234567 2660-10-14 01:49:31       78000142EWU0B3GMIPA2AL</span><br><span class="line">Elapsed: 00:00:00.36</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table order by random_string offset 0 rows fetch next 5 rows only;</span><br><span class="line">   id   |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">--------+---------------------+-----------+----------------------</span></span><br><span class="line"> 938145 | 2018-08-04 21:48:33 |        86 | 00008E7XPHROOHEPUYRC</span><br><span class="line"> 686337 | 2018-08-01 23:51:45 |        31 | 00008JW9S5PXE19F4W4M</span><br><span class="line">  19954 | 2073-03-12 01:49:31 |        69 | 0000G3A2KNDLVN61WOSH</span><br><span class="line"> 382404 | 3065-07-20 01:49:31 |        41 | 0000JDLZP2J8VZFOJ44J</span><br><span class="line"> 234567 | 2660-10-14 01:49:31 |        78 | 000142EWU0B3GMIPA2AL</span><br><span class="line">(5 rows)</span><br><span class="line">Time: 12848.595 ms (00:12.849)</span><br></pre></td></tr></table></figure><p>创建random_id,random_string复合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> test_id_string <span class="keyword">on</span> test_table(random_id,random_string);</span><br></pre></td></tr></table></figure><ol><li>查询某条记录</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table where random_id=74 and random_string='6PP2R3M0K4ARK411VFC3';</span><br><span class="line"></span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- -------------------------------------</span></span><br><span class="line">      4067 2018-07-25 02:20:35       746PP2R3M0K4ARK411VFC3</span><br><span class="line">Elapsed: 00:00:00.00</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table where random_id=74 and random_string='6PP2R3M0K4ARK411VFC3';</span><br><span class="line">  id  |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">------+---------------------+-----------+----------------------</span></span><br><span class="line"> 4067 | 2018-07-25 02:20:35 |        74 | 6PP2R3M0K4ARK411VFC3</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 10.488 ms</span><br></pre></td></tr></table></figure><ol start="2"><li>orderby</li></ol><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test_table order by random_id,random_string offset 0 rows fetch next 5 rows only;</span><br><span class="line">ID INC_DATETIME RANDOM_IDRANDOM_STRING</span><br><span class="line"><span class="comment">---------- ------------------- ---------- ------------------------------</span></span><br><span class="line">    231792 2018-07-27 17:36:000000LENLB2SJ8M8AZKTOD</span><br><span class="line">    691626 2018-08-02 01:19:540003GODBKGMRMZC3LTK8Z</span><br><span class="line">    582719 3613-12-29 01:49:3100052V1U6439AGAAAW3QZ</span><br><span class="line">    762898 2018-08-02 21:07:4600081R0VHHHJTRTPTL8RG</span><br><span class="line">    141007 2404-08-17 01:49:310008PFJM81W6NR83WFNXQ</span><br><span class="line">Elapsed: 00:00:00.33</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select * from test_table order by random_id,random_string offset 0 rows fetch next 5 rows only;</span><br><span class="line">   id   |    inc_datetime     | random_id |    random_string</span><br><span class="line"><span class="comment">--------+---------------------+-----------+----------------------</span></span><br><span class="line"> 231792 | 2018-07-27 17:36:00 |         0 | 000LENLB2SJ8M8AZKTOD</span><br><span class="line"> 691626 | 2018-08-02 01:19:54 |         0 | 003GODBKGMRMZC3LTK8Z</span><br><span class="line"> 582719 | 3613-12-29 01:49:31 |         0 | 0052V1U6439AGAAAW3QZ</span><br><span class="line"> 762898 | 2018-08-02 21:07:46 |         0 | 0081R0VHHHJTRTPTL8RG</span><br><span class="line"> 141007 | 2404-08-17 01:49:31 |         0 | 008PFJM81W6NR83WFNXQ</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">Time: 12857.763 ms (00:12.858)</span><br></pre></td></tr></table></figure><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_name,b.fee <span class="keyword">from</span> <span class="keyword">users</span> a,phone_fee b <span class="keyword">where</span> a.user_id=b.user_id <span class="keyword">and</span> a.user_id=<span class="number">4999998</span>;</span><br><span class="line"></span><br><span class="line">USER_NAME  FEE</span><br><span class="line"><span class="comment">-------------------------------------------------- ----------</span></span><br><span class="line">C58IV8Z0HKYO       297.78</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.27</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998;</span><br><span class="line">  user_name   |  fee</span><br><span class="line"><span class="comment">--------------+--------</span></span><br><span class="line"> C58IV8Z0HKYO | 297.78</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 139.633 ms</span><br></pre></td></tr></table></figure><p>psql的执行计划<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testdb=# explain select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998;</span><br><span class="line">                                                                         QUERY PLAN</span><br><span class="line"></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"> Nested Loop  (cost=20000.00..52502.50 rows=1000000 width=134)</span><br><span class="line">   -&gt;  Foreign Scan on users a  (cost=10000.00..20000.00 rows=1000 width=134)</span><br><span class="line">         Oracle query: <span class="keyword">SELECT</span> <span class="comment">/*f121f12a8cbc233ce7f3a1c56794af92*/</span> r1.<span class="string">"USER_ID"</span>, r1.<span class="string">"USER_NAME"</span></span><br><span class="line"> <span class="keyword">FROM</span> <span class="string">"DBUSER"</span>.<span class="string">"USERS"</span> r1 <span class="keyword">WHERE</span> (r1.<span class="string">"USER_ID"</span> = <span class="number">4999998</span>)</span><br><span class="line">   -&gt;  Materialize  (<span class="keyword">cost</span>=<span class="number">10000.00</span>.<span class="number">.20005</span><span class="number">.00</span> <span class="keyword">rows</span>=<span class="number">1000</span> width=<span class="number">32</span>)</span><br><span class="line">         -&gt;  Foreign <span class="keyword">Scan</span> <span class="keyword">on</span> phone_fee b  (<span class="keyword">cost</span>=<span class="number">10000.00</span>.<span class="number">.20000</span><span class="number">.00</span> <span class="keyword">rows</span>=<span class="number">1000</span> width=<span class="number">32</span>)</span><br><span class="line">               <span class="keyword">Oracle</span> <span class="keyword">query</span>: <span class="keyword">SELECT</span> <span class="comment">/*d1bc90927d98c625ddda179fef4df315*/</span> r2.<span class="string">"USER_ID"</span>, r2.<span class="string">"FEE"</span></span><br><span class="line"> <span class="keyword">FROM</span> <span class="string">"DBUSER"</span>.<span class="string">"PHONE_FEE"</span> r2 <span class="keyword">WHERE</span> (r2.<span class="string">"USER_ID"</span> = <span class="number">4999998</span>)</span><br><span class="line">(<span class="number">6</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>orderby</p><ul><li>sqlplus</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc  offset 0 rows fetch next 5 rows only;</span><br><span class="line"></span><br><span class="line">   USER_ID  FEE FEE_DATE</span><br><span class="line"><span class="comment">---------- ---------- ---------</span></span><br><span class="line">   4999998     297.78 30-APR-15</span><br><span class="line">   4999997     243.36 31-MAY-15</span><br><span class="line">   499999669.79 29-JAN-12</span><br><span class="line">   499999291.03 07-OCT-17</span><br><span class="line">   4999992     268.93 01-FEB-15</span><br><span class="line"></span><br><span class="line">Elapsed: 00:00:00.71</span><br></pre></td></tr></table></figure><ul><li>oracle_fdw</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testdb=# select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc  offset 0 rows fetch next 5 rows only;</span><br><span class="line"> user_id |  fee   |  fee_date</span><br><span class="line"><span class="comment">---------+--------+------------</span></span><br><span class="line"> 4999998 | 297.78 | 2015-04-30</span><br><span class="line"> 4999997 | 243.36 | 2015-05-31</span><br><span class="line"> 4999996 |  69.79 | 2012-01-29</span><br><span class="line"> 4999992 |  91.03 | 2017-10-07</span><br><span class="line"> 4999992 | 268.93 | 2015-02-01</span><br><span class="line">(5 rows)</span><br><span class="line"></span><br><span class="line">Time: 27477.661 ms (00:27.478)</span><br></pre></td></tr></table></figure><p>psql的执行计划<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">testdb=# explain select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc  offset 0 rows fetch next 5 rows only;</span><br><span class="line"></span><br><span class="line">   QUERY PLAN</span><br><span class="line"></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">----------------</span></span><br><span class="line"> Limit  (cost=20016.61..20016.62 rows=5 width=36)</span><br><span class="line">   -&gt;  Sort  (cost=20016.61..20019.11 rows=1000 width=36)</span><br><span class="line">         Sort Key: users.user_id DESC</span><br><span class="line">         -&gt;  Foreign Scan  (cost=10000.00..20000.00 rows=1000 width=36)</span><br><span class="line">               Oracle query: <span class="keyword">SELECT</span> <span class="comment">/*c6de86645f2edcce90957e3283ade08d*/</span> r1.<span class="string">"USER_ID"</span>, r2.<span class="string">"FEE"</span></span><br><span class="line">, r2.<span class="string">"FEE_DATE"</span> <span class="keyword">FROM</span> (<span class="string">"DBUSER"</span>.<span class="string">"USERS"</span> r1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">"DBUSER"</span>.<span class="string">"PHONE_FEE"</span> r2 <span class="keyword">ON</span> (r1.<span class="string">"USER_ID"</span> =</span><br><span class="line"> r2.<span class="string">"USER_ID"</span>))</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>oracle session中执行的sql</p><p><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180802105716.png" alt=""></p><p>流量情况</p><p><img src="https://raw.githubusercontent.com/oYo-Byte/img_libs/master/blog/20180802105550.png" alt=""></p><p>可见oracle_fdw实质上发送的是连接sql，拿到oracle返回的结果，再进行排序的。因此中间消耗的时间里，网络传输数据的消耗是占很大部分的。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>oracle_fdw的查询效率主要受发送给oracle的sql查询结果集的数据量影响的，结果集越大，网络IO消耗越多，对查询的影响越大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在PostgreSQL中使用oracle-fdw&quot;&gt;&lt;a href=&quot;#在PostgreSQL中使用oracle-fdw&quot; class=&quot;headerlink&quot; title=&quot;在PostgreSQL中使用oracle_fdw&quot;&gt;&lt;/a&gt;在PostgreSQL中使用
      
    
    </summary>
    
    
  </entry>
  
</feed>
