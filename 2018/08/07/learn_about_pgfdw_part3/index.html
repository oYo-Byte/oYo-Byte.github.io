<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    学习PostgreSQL的FDW(#3)-其他函数说明 | oYo-Byte
  </title>
  <meta name="description" content="oYo-Byte&#39;s blog">
  
  <meta name="keywords" content="
  PostgreSQL,FDW
  ">
  
  <meta name="author" content="oYo-Byte">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">

  <link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://avatars2.githubusercontent.com/u/8343269?s=460&amp;v=4"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 6 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 4 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 2 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">oYo-Byte</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    oYo-Byte

    <span class="post-date float-right" title="{{moment(1533635241871).format('MMM DD, YYYY, h:mm:ss A')}}">
      <i class="fa fa-pencil-square-o"></i>
      {{moment(1533635241871).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>学习PostgreSQL的FDW(#3)-其他函数说明</h1>
    <p>上两篇文章主要介绍了实现FDW的7个必须实现的扫描相关的回调函数，<a href="https://oyo-byte.github.io/2018/08/03/learn_about_pgfdw/" target="_blank" rel="noopener">学习PostgreSQL的FDW(#1)</a>，<br><a href="https://oyo-byte.github.io/2018/08/07/learn_about_pgfdw_part2/" target="_blank" rel="noopener">学习PostgreSQL的FDW(#2)-源码跟踪</a>，这边就继续说说其余32个回调函数</p>
<h2 id="用于扫描外部连接的回调函数"><a href="#用于扫描外部连接的回调函数" class="headerlink" title="用于扫描外部连接的回调函数"></a>用于扫描外部连接的回调函数</h2><p>如果一个 FDW 支持远程执行外部连接（而不是先把两个表的数据取到本地然后做本地连接），它应该提供这个回调函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">GetForeignJoinPaths (PlannerInfo *root,</span><br><span class="line">                     RelOptInfo *joinrel,</span><br><span class="line">                     RelOptInfo *outerrel,</span><br><span class="line">                     RelOptInfo *innerrel,</span><br><span class="line">                     JoinType jointype,</span><br><span class="line">                     JoinPathExtraData *extra);</span><br></pre></td></tr></table></figure></p>
<p>它为两个（或更多）同属于一台外部服务器的外部表的连接创建可能的访问路径。这个可选的函数会在查询规划过程中被调用。和<code>GetForeignPaths</code>一样，这个函数应该为提供的joinrel生成ForeignPath路径，并且调用add_path把这些路径加入到该连接应该考虑的路径集合中。但是和<code>GetForeignPaths</code>不一样的是，不需要这个函数产生最少一个路径，因为涉及本地连接的路径总是可用的。</p>
<p>注意的是，对于相同的连接关系，将会重复调用此函数来生成内外关系的不同组合。FDW需要负责最小化其中重复的工作。</p>
<p>如果一个ForeignPath路径被选中用于该连接，它将在整个连接处理中存在，为其中的成分表和子连接产生的路径将不会被使用。后续对该连接路径的处理大部分和扫描单个外部表的路径一样。一点不同是ForeignScan计划节点的scanrelid应该被设置为零，因为它表示的不是单个关系，而是用ForeignScan节点的fs_relids属性来表示被连接的关系集合（fs_relids会被核心规划器代码自动设置，不需要由 FDW 填充）。另一点不同是，由于一个远程连接的列的列表无法在系统目录中找到，FDW必须用一个合适的TargetEntry节点列表来填充fdw_scan_tlist，表示运行时它返回的元组中提供的列的集合。</p>
<h2 id="用于规划扫描-连接-后处理的回调函数"><a href="#用于规划扫描-连接-后处理的回调函数" class="headerlink" title="用于规划扫描/连接 后处理的回调函数"></a>用于规划扫描/连接 后处理的回调函数</h2><p>如果一个FDW支持执行远程的扫描/连接 后处理，例如远程聚集，应该事先这个回调函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">GetForeignUpperPaths(PlannerInfo *root,</span><br><span class="line">                     UpperRelationKind stage,</span><br><span class="line">                     RelOptInfo *input_rel,</span><br><span class="line">                     RelOptInfo *output_rel,</span><br><span class="line">                     <span class="keyword">void</span> *extra);</span><br></pre></td></tr></table></figure></p>
<p>为<em>上层关系</em>处理创建可能的访问路径，这是规划器针对所有扫描/连接后查询处理的术语，例如聚集、窗口函数、排序和表更新。在查询规划期间会调用这个可选的函数。当前，只有当该查询中涉及的所有基本关系都属于同一个 FDW 时才会调用这个函数。这个函数应该让 FDW 知道如何远程执行的任何扫描/连接 后处理生成ForeignPath路径，并且调用add_path把这些路径加入到上层关系中。就GetForeignJoinPaths来说，并不要求这个函数在创建任何路径时都能成功，因为涉及本地处理的路径总是可行的。</p>
<p>stage参数表示当前正在考虑的是哪一个扫描/连接后处理步骤。output_rel是接收表示这一个步骤的路径的上层关系，而input_rel是表示这个步骤输入的关系。extra参数提供了其他详细信息。目前，它仅能设置成UPPERREL_PARTIAL_GROUP_AGG或UPPERREL_GROUP_AGG，在这种情况下，它指向的是GroupPathExtraData结构体。（注意被加入到output_rel中的ForeignPath路径通常对input_rel的路径没有直接的依赖，因为它们的处理被认为是在外部处理的。不过，检查为前一个处理步骤生成的路径有助于避免冗余的规划工作）。</p>
<p>使用gdb追踪调用情况<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b postgresGetForeignUpperPaths</span><br><span class="line">Breakpoint 1 at 0x7f2cea563a20: file postgres_fdw.c, line 5437.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, postgresGetForeignUpperPaths (root=0xf7ce50, stage=UPPERREL_GROUP_AGG, </span><br><span class="line">    input_rel=0xf7d3d0, output_rel=0x1063910, extra=0x7ffc84ff94e0) at postgres_fdw.c:5437</span><br><span class="line">5437		<span class="keyword">if</span> (!input_rel-&gt;fdw_private ||</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  postgresGetForeignUpperPaths (root=0xf7ce50, stage=UPPERREL_GROUP_AGG, input_rel=0xf7d3d0, output_rel=0x1063910, extra=0x7ffc84ff94e0) at postgres_fdw.c:5437</span></span><br><span class="line"><span class="comment">#1  0x00000000006807bf in create_ordinary_grouping_paths (root=root@entry=0xf7ce50, input_rel=input_rel@entry=0xf7d3d0, grouped_rel=grouped_rel@entry=0x1063910, agg_costs=agg_costs@entry=0x7ffc84ff94b0, gd=gd@entry=0x0, extra=extra@entry=0x7ffc84ff94e0, partially_grouped_rel_p=partially_grouped_rel_p@entry=0x7ffc84ff9488) at planner.c:4059</span></span><br><span class="line"><span class="comment">#2  0x00000000006831e9 in create_grouping_paths (gd=0x0, agg_costs=0x7ffc84ff94b0, target_parallel_safe=true, target=0x1063768, input_rel=0xf7d3d0, root=0xf7ce50) at planner.c:3783</span></span><br><span class="line"><span class="comment">#3  grouping_planner (root=root@entry=0xf7ce50, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:2037</span></span><br><span class="line"><span class="comment">#4  0x0000000000684218 in subquery_planner (glob=glob@entry=0xf7cdc0, parse=parse@entry=0xf7c6a8, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:966</span></span><br><span class="line"><span class="comment">#5  0x0000000000685236 in standard_planner (parse=0xf7c6a8, cursorOptions=256, boundParams=0x0) at planner.c:405</span></span><br><span class="line"><span class="comment">#6  0x000000000072178c in pg_plan_query (querytree=querytree@entry=0xf7c6a8, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809</span></span><br><span class="line"><span class="comment">#7  0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875</span></span><br><span class="line"><span class="comment">#8  0x0000000000721cda in exec_simple_query (query_string=0xf7b810 "select count(*) from t_fdw ;") at postgres.c:1050</span></span><br><span class="line"><span class="comment">#9  0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0xfa5528, dbname=0xfa5410 "fdw", username=&lt;optimized out&gt;) at postgres.c:4153</span></span><br><span class="line"><span class="comment">#10 0x000000000047a861 in BackendRun (port=0xf9d3f0) at postmaster.c:4361</span></span><br><span class="line"><span class="comment">#11 BackendStartup (port=0xf9d3f0) at postmaster.c:4033</span></span><br><span class="line"><span class="comment">#12 ServerLoop () at postmaster.c:1706</span></span><br><span class="line"><span class="comment">#13 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0xf763c0) at postmaster.c:1379</span></span><br><span class="line"><span class="comment">#14 0x000000000047b2a1 in main (argc=3, argv=0xf763c0) at main.c:228</span></span><br></pre></td></tr></table></figure></p>
<h2 id="更新外部表的回调函数"><a href="#更新外部表的回调函数" class="headerlink" title="更新外部表的回调函数"></a>更新外部表的回调函数</h2><p>如果一个FDW支持可写的外部表，根据FDW的需要和功能，应该提供以下某些或者全部回调函数：</p>
<ul>
<li>AddForeignUpdateTargets  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">AddForeignUpdateTargets(Query *parsetree,</span><br><span class="line">                        RangeTblEntry *target_rte,</span><br><span class="line">                        Relation target_relation);</span><br></pre></td></tr></table></figure>
<p>UPDATE和DELETE操作是在之前由表扫描函数取出的行上被执行的。FDW可能需要额外的信息（例如一个行ID或主键列的值）来保证它能够找到要更新或删除的准确行。要支持这些要求，个函数可以向列列表中增加额外的隐藏或“junk”的目标列，它们在一个UPDATE或DELETE期间会被从外部表中获取。</p>
<p>要做到这一点，向parsetree-&gt;targetList中增加TargetEntry项，它们包含要被获取的额外值的表达式。每一个这样的项必须被标记为resjunk = true，并且必须有一个可区分的resname用于在执行期间标识它。请避免使用匹配ctidN、wholerow或wholerowN的名字，因为核心系统可能会生成使用这些名字的junk列。如果额外的表达式比简单的Vars更复杂，在将它们添加到目标列表之前，必须通过eval_const_expressions运行它们。</p>
<p>这个函数在重写器中被调用，而不是在规划器中，因此可用的信息与在规划例程中的有点区别。parsetree是UPDATE或DELETE命令的分析树，而target_rte和target_relation描述目标外部表。</p>
<p>如果<code>AddForeignUpdateTargets</code>指针被设置为NULL，则不会有额外的目标表达式被加入（这将使得我们不可能实现DELETE操作，而UPDATE则还有可能是可行的，前提是FDW依赖一个未改变的主键来标识行）。</p>
<ul>
<li>PlanForeignModify  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List *</span><br><span class="line">PlanForeignModify(PlannerInfo *root,</span><br><span class="line">                  ModifyTable *plan,</span><br><span class="line">                  Index resultRelation,</span><br><span class="line">                  <span class="keyword">int</span> subplan_index);</span><br></pre></td></tr></table></figure>
<p>执行外部表上插入、更新或删除所需的任何附加规划动作。这个函数生成FDW私有信息，该信息将被附加到执行该更新动作的ModifyTable计划节点。这个私有信息的形式必须是一个List，并将会在执行阶段被传递给BeginForeignModify。</p>
<p>root是规划器关于该查询的全局信息。plan是ModifyTable计划节点，它除了fdwPrivLists属性之外是完整的。resultRelation通过目标外部表的范围表索引来标识它。subplan_index标识这是ModifyTable计划节点的哪个目标，从零开始计数；如果你希望索引到plan-&gt;plans或其他plan节点的子结构中，请使用它。</p>
<p>如果<code>PlanForeignModify</code>指针被设置为NULL，则不会有额外的计划时动作被执行，并且传递给BeginForeignModify的fdw_private列表也将为 NIL。</p>
<ul>
<li>BeginForeignModify  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">BeginForeignModify (ModifyTableState *mtstate,</span><br><span class="line">                    ResultRelInfo *rinfo,</span><br><span class="line">                    List *fdw_private,</span><br><span class="line">                    <span class="keyword">int</span> subplan_index,</span><br><span class="line">                    <span class="keyword">int</span> eflags);</span><br></pre></td></tr></table></figure>
<p>开始执行一个外部表修改操作。这个函数在执行器启动期间被调用。它应该执行任何先于实际表修改的初始化工作。随后，<code>ExecForeignInsert</code>、<code>ExecForeignUpdate</code>或<code>ExecForeignDelete</code>将被为每一个将被插入、更新或删除的元组调用。</p>
<p>mtstate是要被执行的ModifyTable计划节点的状态信息；通过这个结构可以得到关于规划和执行阶段的全局数据。rinfo是描述目标外部表的ResultRelInfo结构（ResultRelInfo的ri_FdwState属性用于FDW来存储它在此操作中需要的任何私有状态）。fdw_private包含<code>PlanForeignModify</code>生成的私有数据。subplan_index标识这是ModifyTable计划节点的哪个目标。eflags包含描述执行器对该计划节点操作模式的标志位。</p>
<p>注意当(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)为真，这个函数不应执行任何外部可见的动作；它只应该做最少的工作来创建<code>ExplainForeignModify</code>和<code>EndForeignModify</code>可用的节点状态。</p>
<p>如果<code>BeginForeignModify</code>指针被设置为NULL，在执行器启动期间将不会采取任何动作。</p>
<ul>
<li>ExecForeignInsert</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TupleTableSlot *</span><br><span class="line">ExecForeignInsert(EState *estate,</span><br><span class="line">                  ResultRelInfo *rinfo,</span><br><span class="line">                  TupleTableSlot *slot,</span><br><span class="line">                  TupleTableSlot *planSlot);</span><br></pre></td></tr></table></figure>
<p>插入一个元组到外部表。estate是查询的全局执行状态。rinfo是描述目标外部表的ResultRelInfo结构。slot包含要被插入的元组；它将匹配外部表的行类型定义。planSlot包含由ModifyTable计划节点的子计划生成的元组；它与slot不同，它可能包含额外的“junk”列（INSERT情况通常不关心planSlot，但是为了完整性还是在这里提供它）。</p>
<p>返回值可以是一个包含实际被插入的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有插入行（还是触发器的结果）。被传入的slot可以被重用于这个目的。</p>
<p>在返回槽中的数据只有在INSERT查询具有一个RETURNING子句或者外部表具有一个AFTER ROW触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据RETURNING子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，否则查询报告的行计数将会是错误的。</p>
<p>如果<code>ExecForeignInsert</code>指针被设置为NULL，尝试向外部表插入将会失败并报告一个错误消息。</p>
<ul>
<li>ExecForeignUpdate</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TupleTableSlot *</span><br><span class="line">ExecForeignUpdate(EState *estate,</span><br><span class="line">                  ResultRelInfo *rinfo,</span><br><span class="line">                  TupleTableSlot *slot,</span><br><span class="line">                  TupleTableSlot *planSlot);</span><br></pre></td></tr></table></figure>
<p>更新外部表中的一个元组。estate是查询的全局执行状态。rinfo是描述目标外部表的ResultRelInfo结构。slot包含元组的新数据；它将匹配外部表的行类型定义。planSlot包含由ModifyTable计划节点的子计划生成的元组；它与slot不同，它可能包含额外的“junk”列。特殊地，任何<code>AddForeignUpdateTargets</code>所要求的junk列在这个槽中都是有效的。</p>
<p>返回值可以是一个包含实际被更新的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有更新行（还是触发器的结果）。被传入的slot可以被重用于这个目的。</p>
<p>在返回槽中的数据只有在UPDATE查询具有一个RETURNING子句或者外部表具有一个AFTER ROW触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据RETURNING子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，否则查询报告的行计数将会是错误的。</p>
<p>如果<code>ExecForeignUpdate</code>指针被设置为NULL，尝试更新外部表将会失败并报告一个错误消息。</p>
<ul>
<li>ExecForeignDelete </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TupleTableSlot *</span><br><span class="line">ExecForeignDelete(EState *estate,</span><br><span class="line">                  ResultRelInfo *rinfo,</span><br><span class="line">                  TupleTableSlot *slot,</span><br><span class="line">                  TupleTableSlot *planSlot);</span><br></pre></td></tr></table></figure>
<p>从外部表删除一个元组。estate是查询的全局执行状态。rinfo是描述目标外部表的ResultRelInfo结构。slot在调用时不包含任何有用的东西，但是可以被用于保持被返回的元组。planSlot包含由ModifyTable计划节点的子计划生成的元组；特殊地，它将携带AddForeignUpdateTargets所要求的任意junk列。junk列被用来标识要被删除的元组。</p>
<p>返回值可以是一个包含实际被删除的数据的槽，或者为 NULL 表示实际没有删除行（还是触发器的结果）。被传入的slot可以被重用于这个目的。</p>
<p>在返回槽中的数据只有在DELETE查询具有一个RETURNING子句或者外部表具有一个AFTER ROW触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据RETURNING子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，否则查询报告的行计数将会是错误的。</p>
<p>如果<code>ExecForeignDelete</code>指针被设置为NULL，尝试从外部表中删除将会失败并报告一个错误消息。</p>
<ul>
<li>EndForeignModify</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">EndForeignModify(EState *estate,</span><br><span class="line">                 ResultRelInfo *rinfo);</span><br></pre></td></tr></table></figure>
<p>结束表更新并释放资源。通常释放palloc的内存并不重要，但是打开的文件和到远程服务器的连接等应当被清除。</p>
<p>如果<code>EndForeignModify</code>指针被设置为NULL，在执行器关闭期间不会采取任何动作。</p>
<p><br><br>通过INSERT或COPY FROM插入分区表的元组将路由到分区。如果FDW支持可路由的外表分区，它还应提供以下回调函数。在外部表上执行COPY FROM时也会调用这些函数：</p>
<ul>
<li>BeginForeignInsert</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">BeginForeignInsert(ModifyTableState *mtstate,</span><br><span class="line">                   ResultRelInfo *rinfo);</span><br></pre></td></tr></table></figure>
<p>开始在外表上执行插入操作。在将第一个元组插入到外表中之前，当它是为元组路由选择的分区和在COPY FROM命令中指定的目标时，就会调用此例程。它应该在实际插入之前执行所需的任何初始化。随后，将调用<code>ExecForeignInsert</code>以将每个元组插入到外表中。</p>
<p>mtstate是要被执行的ModifyTable计划节点的状态信息；通过这个结构可以得到关于规划和执行阶段的全局数据。rinfo是描述目标外部表的ResultRelInfo结构（ResultRelInfo的ri_FdwState属性用于FDW来存储它在此操作中需要的任何私有状态）。</p>
<p>当通过COPY FROM命令调用此方法时，不提供mtstate中与计划相关的全局数据，并且随后为每个插入的元组调用的<code>ExecForeignInsert</code>的planSlot参数为NULL，无论外表是为元组路由选择的分区还是在命令中指定的目标。</p>
<p>如果<code>BeginForeignInsert</code>指针设置为NULL，则不会对初始化执行任何操作。</p>
<ul>
<li>EndForeignInsert</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">EndForeignInsert(EState *estate,</span><br><span class="line">                 ResultRelInfo *rinfo);</span><br></pre></td></tr></table></figure>
<p>结束表插入并释放资源。通常释放palloc的内存并不重要，但是打开的文件和到远程服务器的连接等应当被清除。</p>
<p>如果<code>EndForeignInsert</code>指针被设置为NULL，在执行器关闭期间不会采取任何动作。</p>
<p><br></p>

  </article>
</div>


    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<div class='container' id="gitalk-container"></div>
<script>
    var gitalk = new Gitalk({
        clientID: '0f95488e2c5e12bc2a2a',
        clientSecret: 'b01836c08c02e727359d1c8df682e8b65fe41de1',
        repo: 'blog_gitalk',
        owner: 'oYo-Byte',
        admin: ['oYo-Byte'],
		id: md5(location.pathname),
        distractionFreeMode: true,
    })
    gitalk.render('gitalk-container')
</script>




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <a href="http://byte-cloris.com" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2018 oYo-Byte</li>
      <li><a href="http://byte-cloris.com">Home</a></li>
      
      <li><a href="https://github.com/oYo-Byte">Github</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
