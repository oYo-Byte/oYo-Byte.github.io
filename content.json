{"meta":{"title":"oYo-Byte","subtitle":null,"description":"oYo-Byte's blog","author":"oYo-Byte","url":"https://oyo-byte.github.io"},"pages":[{"title":"文章分类","date":"2018-08-07T15:42:51.000Z","updated":"2018-08-07T17:05:27.618Z","comments":true,"path":"categories/index.html","permalink":"https://oyo-byte.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"标签","date":"2018-08-07T15:53:15.000Z","updated":"2018-08-07T17:07:04.412Z","comments":true,"path":"tags/index.html","permalink":"https://oyo-byte.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"使用sysbench测试infocycle_fdw查询性能","slug":"sysbench_benchmark_infocycle_fdw","date":"2018-09-29T06:49:09.062Z","updated":"2018-09-30T09:43:24.553Z","comments":true,"path":"2018/09/29/sysbench_benchmark_infocycle_fdw/","link":"","permalink":"https://oyo-byte.github.io/2018/09/29/sysbench_benchmark_infocycle_fdw/","excerpt":"","text":"测试机器： 原有的InfoCycle虚拟机 信息 操作系统 CentOS6.9 内存 8G CPU 2核4线程 硬盘 机械硬盘 PosgtreSQL版本 11beta3 测试数据量 576000行 sysbench使用的测试脚本：12345678910111213141516171819202122#!/usr/bin/env sysbenchrequire(\"oltp_common\")function prepare_statements() -- We do not use prepared statements here, but oltp_common.sh expects this -- function to be definedendfunction event(thread_id) local begin_query = \"BEGIN\" local commit_query = \"COMMIT\" math.randomseed(os.time()) local begin_pos = math.random(1,9) local end_pos = math.random(begin_pos,10) db_query(begin_query) con:query(string.format(\"SELECT * FROM ecs2 WHERE station='%s' limit 100\",begin_pos)) con:query(string.format(\"SELECT * FROM ecs2 WHERE station BETWEEN '%s' AND '%s' limit 100\",begin_pos, end_pos)) con:query(string.format(\"SELECT * FROM ecs2 WHERE station BETWEEN '%s' AND '%s' ORDER BY archivetime desc limit 100\",begin_pos, end_pos)) db_query(commit_query)end 本次测试1-8个线程，每个线程重复测试3次。每次压测时间为120秒。 样本数据： 使用的测试脚本：1234567891011121314#!/bin/sh for i in 1 2 3 4 5 6 7 8; do for j in 1 2 3; do echo \"doing $i the $j times\" /appdb/sysbench/bin/sysbench --db-driver=pgsql --pgsql-host=192.168.10.82 --pgsql-port=5432 --pgsql-user=atlasdb --pgsql-password=123456 --pgsql-db=infocycle --time=120 --report-interval=5 --threads=$i /appdb/sysbench/share/sysbench/pgotlp.lua run &gt;&gt; /data/sysbench.log ; echo \"sleeping\"; sleep 10; done done 将sysbench输出结果输出到csv：1cat sysbench.log | egrep \" cat|threads:|transactions|queries:|read:|write:|other:|total:|min:|avg:|max:|percentile:\" | tr -d \"\\n\" | sed 's/Number of threads: /\\n/g' | sed 's/\\[/\\n/g' |sed 's/[A-Za-z\\/]\\&#123;1,\\&#125;://g'| sed 's/ \\.//g' | sed -e 's/read\\/write//g' -e 's/approx\\. 95//g' -e 's/per sec.)//g' -e 's/ms//g' -e 's/(//g' -e 's/^.*cat //g' |sed 's/ \\&#123;1,\\&#125;/,/g' 测试结果： 以上结果不可信发现以上结果的QPS有点高，不太可信，所以重新验证一下，发现上面的测试场景中，后面2条的SQL执行要不就是没有返回，要不就是执行出错，并且把事务的开关QPS都算进里面了，导致sysbench测试结果有误。 于是重新整理测试场景，重新测试，这次测试是1-8个线程，每个线程重复测试5次。每次压测时间为120秒。 场景1：查询某个station的某个type的某个时间的记录123456789101112131415#!/usr/bin/env sysbenchrequire(\"oltp_common\")function prepare_statements() -- We do not use prepared statements here, but oltp_common.sh expects this -- function to be definedendfunction event(thread_id) math.randomseed(os.time()) local station_random = math.random(1, 10) local type_random = math.random(1, 4) local time_random = 1533225600 + 180 * math.random(0, 4799) con:query(string.format(\"SELECT * FROM ecs2 WHERE station='%s' AND type='%s' AND time='%s'\",station_random, type_random, time_random))end 测试时服务器的情况： 1线程时： 2线程时： 3线程时： 4线程时： 5线程时： 6线程时： 7线程时： 8线程时： 测试结果： 场景2：查询某个station的某个type的某一天所有的记录12345678910111213141516#!/usr/bin/env sysbenchrequire(\"oltp_common\")function prepare_statements() -- We do not use prepared statements here, but oltp_common.sh expects this -- function to be definedendfunction event(thread_id) math.randomseed(os.time()) local station_random = math.random(1,10) local type_random = math.random(1,4) local time_random = 1533225600 + 180 * math.random(0, 4798) local time_end_random = time_random + 86400 -- 加一天的范围 con:query(string.format(\"SELECT * FROM ecs2 WHERE station='%s' AND type='%s' AND time BETWEEN '%s' AND '%s'\",station_random, type_random, time_random, time_end_random))end 测试时服务器的情况： 未完待续","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"},{"name":"sysbench","slug":"sysbench","permalink":"https://oyo-byte.github.io/tags/sysbench/"}]},{"title":"使用Jmeter的JDBC连接PostgreSQL进行压力测试","slug":"use_jmeter_connect_postgresql","date":"2018-09-27T08:06:54.529Z","updated":"2018-09-27T09:13:04.265Z","comments":true,"path":"2018/09/27/use_jmeter_connect_postgresql/","link":"","permalink":"https://oyo-byte.github.io/2018/09/27/use_jmeter_connect_postgresql/","excerpt":"","text":"添加驱动使用Jmeter的JDBC功能时，需要添加对应的数据库驱动，将下载好的jar包放到Jmeter安装目录下的lib目录中，然后重启Jmeter使其生效。PostgreSQL的JDBC驱动下载地址：PostgreSQL驱动 在测试计划中添加线程组 可以设置线程数以及循环次数 在线程组中添加数据库连接配置 添加JDBC请求 添加监听器 执行线程","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"Jmeter","slug":"Jmeter","permalink":"https://oyo-byte.github.io/tags/Jmeter/"}]},{"title":"学习PostgreSQL的FDW(#6)-file_fdw源码分析","slug":"learn_about_pgfdw_part6","date":"2018-08-10T06:31:43.897Z","updated":"2018-08-17T08:27:08.522Z","comments":true,"path":"2018/08/10/learn_about_pgfdw_part6/","link":"","permalink":"https://oyo-byte.github.io/2018/08/10/learn_about_pgfdw_part6/","excerpt":"","text":"之前文章介绍了实现FDW的函数，现在来看看PostgreSQL实现的文件的FDW是怎么的吧。PostgreSQL实现的file_fdw的源码可以在PostgreSQL的源码目录下contrib目录下找到。 简介file_fdw支持的数据文件必须是COPY FROM可读格式（text,csv[逗号分隔值],binary）.用这个包装器创建的一个外部表可以有下列选项： 参数 说明 filename 指定要被读取的文件。必须是一个绝对路径名。 必须指定filename或program， 但不能同时指定两个。 program 指定要执行的命令。该命令的标准输出将被读取， 就像使用COPY FROM PROGRAM一样。必须指定program 或filename，但不能同时指定两个。 format 指定数据的格式，和COPY的FORMAT选项相同。即text,csv（逗号分隔值）,binary header 指定文件包含标题行，其中有每一列的名称。在输出时，第一行包含 来自表的列名。在输入时，第一行会被忽略。只有使用 CSV格式时才允许这个选项。 delimiter 指定分隔文件每行中各列的字符。文本格式中默认是一个制表符， 而CSV格式中默认是一个逗号。这必须是一个单一 的单字节字符。使用binary格式时不允许这个选项。 quote 指定一个数据值被引用时使用的引用字符。默认是双引号。 这必须是一个单一的单字节字符。只有使用 CSV格式时才允许这个选项。 escape 指定应该出现在一个匹配quote值的数据字符之前 的字符。默认和quote值一样（这样如果引用字符 出现在数据中，它会被双写）。这必须是一个单一的单字节字符。 只有使用CSV格式时才允许这个选项。 null 指定表示一个空值的字符串。文本格式中默认是 \\N（反斜线-N），CSV格式中默认 是一个未加引用的空串。在你不想区分空值和空串的情况下，即使在文本 格式中你也可能更喜欢空串。使用binary格式时不允许这 个选项。 encoding 指定文件被以encoding_name编码。如果省略这个选项，将使用当前的客户端编码。 添加file_fdw扩展检查PG安装目录的lib/postgresql目录下是否存在file_fdw.so文件，确保安装时已经编译安装了file_fdw扩展。 12345678910fdw=# create extension file_fdw ;CREATE EXTENSIONfdw=# \\dx List of installed extensions Name | Version | Schema | Description --------------+---------+------------+---------------------------------------------------- file_fdw | 1.0 | public | foreign-data wrapper for flat file access plpgsql | 1.0 | pg_catalog | PL/pgSQL procedural language postgres_fdw | 1.0 | public | foreign-data wrapper for remote PostgreSQL servers(3 rows) 测试file_fdw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657fdw=# --创建测试表，并添加数据fdw=# create table tb1(id int,name varchar,password varchar);CREATE TABLEfdw=# insert into tb1 select generate_series(1,50),'oYo',md5(random()::text);INSERT 0 50fdw=# --通过copy拷贝数据到文件fdw=# copy tb1 to '/data/file_fdw/tb1.csv';COPY 50fdw=# --创建外部服务器fdw=# create server file_fdw_server foreign data wrapper file_fdw ;CREATE SERVERfdw=# \\des List of foreign servers Name | Owner | Foreign-data wrapper -----------------+-------+---------------------- file_fdw_server | xdb | file_fdw pg_117_56 | xdb | postgres_fdw(2 rows)fdw=# --创建外部表fdw=# create foreign table tb1_fdw(id int,name varchar,password varchar) server file_fdw_server options(filename '/data/file_fdw/tb1.csv');CREATE FOREIGN TABLEfdw=# \\d tb1_fdw Foreign table \"public.tb1_fdw\" Column | Type | Collation | Nullable | Default | FDW options ----------+-------------------+-----------+----------+---------+------------- id | integer | | | | name | character varying | | | | password | character varying | | | | Server: file_fdw_serverFDW options: (filename '/data/file_fdw/tb1.csv')fdw=# select * from tb1_fdw order by id limit 10; id | name | password ----+------+---------------------------------- 1 | oYo | 99c0aa4a3ad2128e6ea55522012d8806 2 | oYo | a126e01cfdfd4717a1d79b45a42a3bb6 3 | oYo | f031835b6c57d4a8781309e05542eb18 4 | oYo | 7bea90889b4aa3d0fe67ddbdba68be8e 5 | oYo | 01e38c84d7ca2e140f00efc9a9d7a767 6 | oYo | 28269e1942431e7970c638023953f43b 7 | oYo | fcf45570efa8616e4081b81e6d514433 8 | oYo | 5c90103b272cc172d052d7fabb748188 9 | oYo | cb8b46761425c64390f77cf1557bb1ae 10 | oYo | 634404bf272dd5610e1b7caf7e1a1542(10 rows)fdw=# --执行计划fdw=# explain select * from tb1_fdw order by id limit 10; QUERY PLAN ------------------------------------------------------------------------- Limit (cost=3.55..3.58 rows=10 width=68) -&gt; Sort (cost=3.55..3.61 rows=21 width=68) Sort Key: id -&gt; Foreign Scan on tb1_fdw (cost=0.00..3.10 rows=21 width=68) Foreign File: /data/file_fdw/tb1.csv Foreign File Size: 1991 b(6 rows) 数据结构 FileFdwOption 123456789/* * Describes the valid options for objects that use this wrapper. * 此外部器可用的选项对象 */struct FileFdwOption&#123; const char *optname; Oid optcontext; /* Oid of catalog in which option may appear */&#125;; 12345678910111213141516171819202122232425262728293031323334/* * Valid options for file_fdw. * 可以的选项 * These options are based on the options for the COPY FROM command. * But note that force_not_null and force_null are handled as boolean options * attached to a column, not as table options. * * Note: If you are adding new option for user mapping, you need to modify * fileGetOptions(), which currently doesn't bother to look at user mappings.*/static const struct FileFdwOption valid_options[] = &#123; /* Data source options */ &#123;\"filename\", ForeignTableRelationId&#125;, &#123;\"program\", ForeignTableRelationId&#125;, /* Format options */ /* oids option is not supported */ &#123;\"format\", ForeignTableRelationId&#125;, &#123;\"header\", ForeignTableRelationId&#125;, &#123;\"delimiter\", ForeignTableRelationId&#125;, &#123;\"quote\", ForeignTableRelationId&#125;, &#123;\"escape\", ForeignTableRelationId&#125;, &#123;\"null\", ForeignTableRelationId&#125;, &#123;\"encoding\", ForeignTableRelationId&#125;, &#123;\"force_not_null\", AttributeRelationId&#125;, &#123;\"force_null\", AttributeRelationId&#125;, /* * force_quote is not supported by file_fdw because it's for COPY TO. */ /* Sentinel */ &#123;NULL, InvalidOid&#125;&#125;; FileFdwPlanState 12345678910111213/* * FDW-specific information for RelOptInfo.fdw_private. * 此FDW优化阶段的fdw_private的数据结构体 */typedef struct FileFdwPlanState&#123; char *filename; /*需要读取的文件或程序 file or program to read from */ bool is_program; /*是否是程序 true if filename represents an OS command */ List *options; /*其他选项 merged COPY options, excluding filename and * is_program */ BlockNumber pages; /*物理文件的估算大小 estimate of file's physical size */ double ntuples; /*数据行的估算数量 estimate of number of data rows */&#125; FileFdwPlanState; FileFdwExecutionState 123456789101112/* * FDW-specific information for ForeignScanState.fdw_state. * 执行时的fdw_state的结构体 */typedef struct FileFdwExecutionState&#123; char *filename; /* file or program to read from */ bool is_program; /* true if filename represents an OS command */ List *options; /* merged COPY options, excluding filename and * is_program */ CopyState cstate; /*COPY命令执行时的状态 COPY execution state */&#125; FileFdwExecutionState; 函数 fileIsForeignScanParallelSafe 123456789101112/* * fileIsForeignScanParallelSafe * Reading a file, or external program, in a parallel worker should work * just the same as reading it in the leader, so mark scans safe. * 是否能多并发读取文件 */static boolfileIsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)&#123; return true;&#125; fileGetForeignRelSize 12345678910111213141516171819202122232425262728/* * fileGetForeignRelSize * Obtain relation size estimates for a foreign table * 获取外部表的估计大小 */static voidfileGetForeignRelSize(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)&#123; FileFdwPlanState *fdw_private; /* * Fetch options. We only need filename (or program) at this point, but * we might as well get everything and not need to re-fetch it later in * planning. * 获取fdw的选项参数 */ fdw_private = (FileFdwPlanState *) palloc(sizeof(FileFdwPlanState)); fileGetOptions(foreigntableid, &amp;fdw_private-&gt;filename, &amp;fdw_private-&gt;is_program, &amp;fdw_private-&gt;options); baserel-&gt;fdw_private = (void *) fdw_private; /*估算表大小 Estimate relation size */ estimate_size(root, baserel, fdw_private);&#125; estimate_size 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * Estimate size of a foreign table. * 估算外部表大小 * The main result is returned in baserel-&gt;rows. We also set * fdw_private-&gt;pages and fdw_private-&gt;ntuples for later use in the cost * calculation. */static voidestimate_size(PlannerInfo *root, RelOptInfo *baserel, FileFdwPlanState *fdw_private)&#123; struct stat stat_buf; BlockNumber pages; double ntuples; double nrows; /* * 如果是程序或者获取文件失败，则设置默认值 * Get size of the file. It might not be there at plan time, though, in * which case we have to use a default estimate. We also have to fall * back to the default if using a program as the input. */ if (fdw_private-&gt;is_program || stat(fdw_private-&gt;filename, &amp;stat_buf) &lt; 0) stat_buf.st_size = 10 * BLCKSZ; /* * 将大小转换成页数 * Convert size to pages for use in I/O cost estimate later. */ pages = (stat_buf.st_size + (BLCKSZ - 1)) / BLCKSZ; if (pages &lt; 1) pages = 1; fdw_private-&gt;pages = pages; /* * Estimate the number of tuples in the file. */ if (baserel-&gt;pages &gt; 0) &#123; /* 如果已经执行过ANALYZE，则baserel-&gt;pages的值大于0，直接进行行数计算 * We have # of pages and # of tuples from pg_class (that is, from a * previous ANALYZE), so compute a tuples-per-page estimate and scale * that by the current file size. */ double density; density = baserel-&gt;tuples / (double) baserel-&gt;pages;# // 计算每页的行数密度 ntuples = clamp_row_est(density * (double) pages); //估算行数 &#125; else &#123; /* * Otherwise we have to fake it. We back into this estimate using the * planner's idea of the relation width; which is bogus if not all * columns are being read, not to mention that the text representation * of a row probably isn't the same size as its internal * representation. Possibly we could do something better, but the * real answer to anyone who complains is \"ANALYZE\" ... */ int tuple_width; tuple_width = MAXALIGN(baserel-&gt;reltarget-&gt;width) + MAXALIGN(SizeofHeapTupleHeader);// 计算行宽 ntuples = clamp_row_est((double) stat_buf.st_size / (double) tuple_width);//数据量大小除行宽估算行数 &#125; fdw_private-&gt;ntuples = ntuples; /* 加上提供baserestrictinfo信息扫描后的结果估算行数 * Now estimate the number of rows returned by the scan after applying the * baserestrictinfo quals. */ nrows = ntuples * clauselist_selectivity(root, baserel-&gt;baserestrictinfo, 0, JOIN_INNER, NULL); nrows = clamp_row_est(nrows); /* Save the output-rows estimate for the planner */ baserel-&gt;rows = nrows;&#125; fileGetForeignPaths 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * fileGetForeignPaths * Create possible access paths for a scan on the foreign table * 创建扫描外部表的访问路径 * Currently we don't support any push-down feature, so there is only one * possible access path, which simply returns all records in the order in * the data file. */static voidfileGetForeignPaths(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid)&#123; FileFdwPlanState *fdw_private = (FileFdwPlanState *) baserel-&gt;fdw_private; Cost startup_cost; Cost total_cost; List *columns; List *coptions = NIL; /* 决定是否有选择地执行二进制转换 Decide whether to selectively perform binary conversion */ if (check_selective_binary_conversion(baserel, foreigntableid, &amp;columns)) coptions = list_make1(makeDefElem(\"convert_selectively\", (Node *) columns, -1)); /* 估算代价 Estimate costs */ estimate_costs(root, baserel, fdw_private, &amp;startup_cost, &amp;total_cost); /* * 创建外部路径节点并添加到路径列表中 * Create a ForeignPath node and add it as only possible path. We use the * fdw_private list of the path to carry the convert_selectively option; * it will be propagated into the fdw_private list of the Plan node. */ add_path(baserel, (Path *) create_foreignscan_path(root, baserel, NULL, /* default pathtarget */ baserel-&gt;rows, startup_cost, total_cost, NIL, /* no pathkeys */ NULL, /* no outer rel either */ NULL, /* no extra plan */ coptions)); /* * If data file was sorted, and we knew it somehow, we could insert * appropriate pathkeys into the ForeignPath node to tell the planner * that. */&#125; estimate_costs 123456789101112131415161718192021222324252627282930313233/* * Estimate costs of scanning a foreign table. * 估算代价 * Results are returned in *startup_cost and *total_cost. */static voidestimate_costs(PlannerInfo *root, RelOptInfo *baserel, FileFdwPlanState *fdw_private, Cost *startup_cost, Cost *total_cost)&#123; BlockNumber pages = fdw_private-&gt;pages; double ntuples = fdw_private-&gt;ntuples; Cost run_cost = 0; Cost cpu_per_tuple; /* * We estimate costs almost the same way as cost_seqscan(), thus assuming * that I/O costs are equivalent to a regular table file of the same size. * However, we take per-tuple CPU costs as 10x of a seqscan, to account * for the cost of parsing records. * * In the case of a program source, this calculation is even more divorced * from reality, but we have no good alternative; and it's not clear that * the numbers we produce here matter much anyway, since there's only one * access path for the rel. */ run_cost += seq_page_cost * pages; *startup_cost = baserel-&gt;baserestrictcost.startup; cpu_per_tuple = cpu_tuple_cost * 10 + baserel-&gt;baserestrictcost.per_tuple; run_cost += cpu_per_tuple * ntuples; *total_cost = *startup_cost + run_cost;&#125; fileGetForeignPlan 1234567891011121314151617181920212223242526272829303132333435/* * fileGetForeignPlan * Create a ForeignScan plan node for scanning the foreign table * 创建外部扫描计划 */static ForeignScan *fileGetForeignPlan(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan)&#123; Index scan_relid = baserel-&gt;relid; /* * We have no native ability to evaluate restriction clauses, so we just * put all the scan_clauses into the plan node's qual list for the * executor to check. So all we have to do here is strip RestrictInfo * nodes from the clauses and ignore pseudoconstants (which will be * handled elsewhere). */ scan_clauses = extract_actual_clauses(scan_clauses, false);// 去掉约束语句 /*创建ForeignScan节点 Create the ForeignScan node */ return make_foreignscan(tlist, scan_clauses, scan_relid, NIL, /* no expressions to evaluate */ best_path-&gt;fdw_private, NIL, /* no custom tlist */ NIL, /* no remote quals */ outer_plan);&#125; 未完待续 123456789101112131415161718Datumfile_fdw_handler(PG_FUNCTION_ARGS)&#123; FdwRoutine *fdwroutine = makeNode(FdwRoutine); fdwroutine-&gt;GetForeignRelSize = fileGetForeignRelSize; fdwroutine-&gt;GetForeignPaths = fileGetForeignPaths; fdwroutine-&gt;GetForeignPlan = fileGetForeignPlan; fdwroutine-&gt;ExplainForeignScan = fileExplainForeignScan; fdwroutine-&gt;BeginForeignScan = fileBeginForeignScan; fdwroutine-&gt;IterateForeignScan = fileIterateForeignScan; fdwroutine-&gt;ReScanForeignScan = fileReScanForeignScan; fdwroutine-&gt;EndForeignScan = fileEndForeignScan; fdwroutine-&gt;AnalyzeForeignTable = fileAnalyzeForeignTable; fdwroutine-&gt;IsForeignScanParallelSafe = fileIsForeignScanParallelSafe; PG_RETURN_POINTER(fdwroutine);&#125; 12345fdw=# select pg_backend_pid(); pg_backend_pid ---------------- 1421(1 row) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768[root@localhost data]# gdb -p 1421GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\".For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Attaching to process 1421...(gdb) b fileGetForeignRelSizeBreakpoint 1 at 0x7f223f2cc8a0: file file_fdw.c, line 506.(gdb) b fileGetForeignPathsBreakpoint 2 at 0x7f223f2cc600: file file_fdw.c, line 537.(gdb) b fileGetForeignPlanBreakpoint 3 at 0x7f223f2cc5b0: file file_fdw.c, line 590.(gdb) b fileExplainForeignScanBreakpoint 4 at 0x7f223f2cc500: file file_fdw.c, line 619.(gdb) b fileBeginForeignScanBreakpoint 5 at 0x7f223f2cc2f0: file file_fdw.c, line 651.(gdb) b fileIterateForeignScanBreakpoint 6 at 0x7f223f2cc480: file file_fdw.c, line 704.(gdb) b fileReScanForeignScanBreakpoint 7 at 0x7f223f2cbc50: file file_fdw.c, line 747.(gdb) b fileEndForeignScanBreakpoint 8 at 0x7f223f2cbc30: file file_fdw.c, line 768.(gdb) b fileAnalyzeForeignTableBreakpoint 9 at 0x7f223f2cc3a0: file file_fdw.c, line 783.(gdb) b fileIsForeignScanParallelSafeBreakpoint 10 at 0x7f223f2cbc20: file file_fdw.c, line 835.# 先来看看这个sql语句的解析`explain select * from tb1_fdw order by id limit 10;`# 切换至psqlfdw=# explain select * from tb1_fdw order by id limit 10;# （挂起）# 切换会gdb(gdb) cContinuing.Breakpoint 10, fileIsForeignScanParallelSafe (root=0x16ea238, rel=0x1724fc8, rte=0x16e9958) at file_fdw.c:835835 &#125;(gdb) bt#0 fileIsForeignScanParallelSafe (root=0x16ea238, rel=0x1724fc8, rte=0x16e9958) at file_fdw.c:835#1 0x000000000065df1b in set_rel_consider_parallel (root=root@entry=0x16ea238, rel=rel@entry=0x1724fc8, rte=rte@entry=0x16e9958) at allpaths.c:597#2 0x00000000006609c3 in set_base_rel_sizes (root=&lt;optimized out&gt;) at allpaths.c:279#3 make_one_rel (root=root@entry=0x16ea238, joinlist=joinlist@entry=0x1719a08) at allpaths.c:179#4 0x000000000067de9e in query_planner (root=root@entry=0x16ea238, tlist=tlist@entry=0x16ea708, qp_callback=qp_callback@entry=0x67f290 &lt;standard_qp_callback&gt;, qp_extra=qp_extra@entry=0x7ffe9f3f4fc0) at planmain.c:259#5 0x0000000000681f43 in grouping_planner (root=root@entry=0x16ea238, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:1897#6 0x0000000000684218 in subquery_planner (glob=glob@entry=0x16ea1a8, parse=parse@entry=0x17251d8, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:966#7 0x0000000000685236 in standard_planner (parse=0x17251d8, cursorOptions=256, boundParams=0x0)at planner.c:405#8 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0x17251d8, cursorOptions=&lt;optimized out&gt;, boundParams=boundParams@entry=0x0) at postgres.c:809#9 0x0000000000595a0a in ExplainOneQuery (query=0x17251d8, cursorOptions=&lt;optimized out&gt;, into=0x0, es=0x1724f38, queryString=0x1627810 \"explain select * from tb1_fdw order by id limit 10;\", params=0x0, queryEnv=0x0) at explain.c:365#10 0x0000000000595f54 in ExplainQuery (pstate=pstate@entry=0x1724db8, stmt=stmt@entry=0x16286f0, queryString=queryString@entry=0x1627810 \"explain select * from tb1_fdw order by id limit 10;\", params=params@entry=0x0, queryEnv=queryEnv@entry=0x0, dest=dest@entry=0x1724d28) at explain.c:254#11 0x0000000000726ead in standard_ProcessUtility (pstmt=0x16287a0, queryString=0x1627810 \"explain select * from tb1_fdw order by id limit 10;\", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x1724d28, completionTag=0x7ffe9f3f5470 \"\") at utility.c:672#12 0x0000000000724476 in PortalRunUtility (portal=0x168cf10, pstmt=0x16287a0, isTopLevel=&lt;optimized out&gt;, setHoldSnapshot=&lt;optimized out&gt;, dest=0x1724d28, completionTag=0x7ffe9f3f5470 \"\") at pquery.c:1178#13 0x0000000000725182 in FillPortalStore (portal=portal@entry=0x168cf10, isTopLevel=isTopLevel@entry=true) at pquery.c:1038#14 0x0000000000725b90 in PortalRun (portal=portal@entry=0x168cf10, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x1629528, altdest=altdest@entry=0x1629528, completionTag=completionTag@entry=0x7ffe9f3f5680 \"\") at pquery.c:768#15 0x0000000000721bb7 in exec_simple_query (query_string=0x1627810 \"explain select * from tb1_fdw order by id limit 10;\")at postgres.c:1122#16 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1651528, dbname=0x1651410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#17 0x000000000047a861 in BackendRun (port=0x16493f0) at postmaster.c:4361#18 BackendStartup (port=0x16493f0) at postmaster.c:4033#19 ServerLoop () at postmaster.c:1706#20 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x16223c0) at postmaster.c:1379#21 0x000000000047b2a1 in main (argc=3, argv=0x16223c0) at main.c:228 –&gt; -->","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"},{"name":"file_fdw","slug":"file-fdw","permalink":"https://oyo-byte.github.io/tags/file-fdw/"}]},{"title":"学习PostgreSQL的FDW(#5)-辅助函数介绍","slug":"learn_about_pgfdw_part5","date":"2018-08-10T06:29:20.579Z","updated":"2018-08-16T17:24:58.054Z","comments":true,"path":"2018/08/10/learn_about_pgfdw_part5/","link":"","permalink":"https://oyo-byte.github.io/2018/08/10/learn_about_pgfdw_part5/","excerpt":"","text":"PG核心服务器提供了多个辅助函数，是外部包装器的开发者们能很容易地访问到FDW相关对象的属性，例如FDW选项。使用这些函数，只需在源文件中引入foreign/foreign.h头文件即可。 函数 代码 说明 GetForeignDataWrapper ForeignDataWrapper * GetForeignDataWrapper(Oid fdwid); 为具有给定 OID 的外部数据包装器返回一个ForeignDataWrapper对象。一个ForeignDataWrapper对象包含该FDW的特性 GetForeignServer ForeignServer * GetForeignServer(Oid serverid); 为一个具有给定 OID 的外部服务器返回ForeignServer对象。一个ForeignServer对象包含该服务器的特性 GetUserMapping UserMapping * GetUserMapping(Oid userid, Oid serverid); 为在给定服务器上的给定角色的用户映射返回UserMapping对象（如果指定用户没有映射，它将返回PUBLIC的映射，如果也没有则抛出错误）。一个UserMapping对象包含该用户映射的特性 GetForeignTable ForeignTable * GetForeignTable(Oid relid); 为一个具有给定 OID 的外部表返回ForeignTable对象。一个ForeignTable对象包含该外部表的特性 GetForeignColumnOptions List * GetForeignColumnOptions(Oid relid, AttrNumber attnum); 为一个具有给定外部表 OID 和属性号的列返回针对每一列的FDW选项，形式为一个DefElem列表。如果该列没有选项则返回 NIL。 GetForeignDataWrapperByName ForeignDataWrapper GetForeignDataWrapperByName(const char name, bool missing_ok); 为一个具有给定名称的外部数据包装器返回ForeignDataWrapper对象。如果包装器没有找到，在missing_ok为真时返回 NULL，否则抛出一个错误。 GetForeignServerByName ForeignServer GetForeignServerByName(const char name, bool missing_ok); 为一个具有给定名称的外部服务器返回ForeignServer对象。如果该服务器没有被找到，在missing_ok为真时返回 NULL，否则抛出一个错误。","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"}]},{"title":"学习PostgreSQL的FDW(#4)-其他函数说明 II","slug":"learn_about_pgfdw_part4","date":"2018-08-08T09:52:34.432Z","updated":"2018-08-08T10:00:12.436Z","comments":true,"path":"2018/08/08/learn_about_pgfdw_part4/","link":"","permalink":"https://oyo-byte.github.io/2018/08/08/learn_about_pgfdw_part4/","excerpt":"","text":"继上篇学习PostgreSQL的FDW(#3)-其他函数说明 I，继续说说其余回调函数 用于行锁定的FDW回调函数如果一个FDW 希望支持后期行锁定，必须提供以下回调函数： GetForeignRowMarkType 123RowMarkTypeGetForeignRowMarkType (RangeTblEntry *rte, LockClauseStrength strength); 报告要对一个外部表使用哪个行标记选项。rte是该表的RangeTblEntry节点，而strength描述FOR UPDATE/SHARE子句（如果有）所要求的锁长度。结果必须是RowMarkType枚举类型的一个成员。 这个函数在查询规划期间会为每一个出现在UPDATE、DELETE或者SELECT FOR UPDATE/SHARE查询中的外部表调用，并且该外部表不是UPDATE和DELETE的目标。 如果GetForeignRowMarkType指针被设置为NULL，将总是使用ROW_MARK_COPY选项（这意味着将不会调用RefetchForeignRow，因此也不必提供它）。 RefetchForeignRow 12345HeapTupleRefetchForeignRow(EState *estate, ExecRowMark *erm, Datum rowid, bool *updated); 从外部表中重新取得一个元组，如有必要先锁定它。estate是该查询的全局执行状态。erm是描述目标外部表以及要获取的行锁类型（如果有）的ExecRowMark结构。rowid标识要取得的元组。updated是一个输出参数。 这个函数应该返回被取得的元组的一个已经分配内存的拷贝，如果无法得到行锁则返回NULL。要获得的行锁由erm-&gt;markType定义，它是之前由GetForeignRowMarkType返回的值（ROW_MARK_REFERENCE标识只重新取得元组但不获得任何锁，这个例程将不会看到ROW_MARK_COPY）。 此外，如果取得的是一个更新过的版本而不是之前获得的同一版本，*updated应被设置为true（如果 FDW 无法确定这一点，推荐总是返回true）。 注意在默认情况下，获取行锁失败应该导致产生错误。如果erm-&gt;waitPolicy指定了SKIP LOCKED，只有返回NULL才是合适的。 rowid是要被重新取得的行之前读到的ctid值。尽管rowid值被作为Datum传递，但是目前它只能被读作tid。选择该函数 API 是希望未来能允许其他的行 ID 数据类型。 如果RefetchForeignRow指针被设置为NULL，重新取得行的尝试将会失败并伴随有一个错误消息。 RecheckForeignScan 123boolRecheckForeignScan(ForeignScanState *node, TupleTableSlot *slot); 重新检查之前返回的元组是否仍然匹配相关的扫描和连接条件，并且可能提供该元组的一个修改版本。对于不执行连接下推的外部数据包装器，通常把这设置为NULL并且恰当地设置fdw_recheck_quals会更方便。不过当外部连接被下推时，把与所有基表相关的检查重新应用在结果元组上是不够的，即便所有需要的属性都存在也是如此，因为匹配某个条件失败可能会导致某些属性变成 NULL，而不是没有元组被返回。RecheckForeignScan能够重新检查条件，并且在它们仍然满足时返回真，否则返回假，但是它也能够在提供的槽中存储一个替换元组。 要实现连接下推，外部数据包装器通常将构造一个可替代的本地连接计划，它只被用来做重新检查。这将变成ForeignScan的外子计划。在需要一次重新检查时，这个子计划可以被执行并且结果元组可以被存储在槽中。这个计划不需要效率很高，因为不会有基表返回超过一行。例如，它可以把所有的连接实现为嵌套循环。函数GetExistingLocalJoinPath可以被用来在已有的路径中搜索合适的本地连接路径，它可以被用作替换的本地连接计划。GetExistingLocalJoinPath会在指定连接关系的路径列表中搜索一个非参数化路径（如果没有找到这样的路径，它会返回 NULL，这种情况下外部数据包装器可以自行构造本地路径或者可以选择不为这个连接创建访问路径）。 EXPLAIN 相关FDW回调函数 ExplainForeignScan 123voidExplainForeignScan(ForeignScanState *node, ExplainState *es); 为一个外部表扫描打印额外的EXPLAIN输出。这个函数可以调用ExplainPropertyText和相关函数来向EXPLAIN输出中增加域。es中的标志域可以被用来决定什么将被打印，并且ForeignScanState节点的状态可以被检查来为EXPLAIN ANALYZE提供运行时统计数据。 如果ExplainForeignScan指针被设置为NULL，在EXPLAIN期间不会打印任何额外的信息。 ExplainForeignModify 123456voidExplainForeignModify(ModifyTableState *mtstate, ResultRelInfo *rinfo, List *fdw_private, int subplan_index, struct ExplainState *es); 为一个外部表更新打印额外的EXPLAIN输出。这个函数可以调用ExplainPropertyText和相关函数来向EXPLAIN输出中增加域。es中的标志域可以被用来决定什么将被打印，并且ModifyTableState节点的状态可以被检查来为EXPLAIN ANALYZE提供运行时统计数据。前四个参数和BeginForeignModify相同。 如果ExplainForeignModify指针被设置为NULL，在EXPLAIN期间不会打印任何额外的信息。 ExplainDirectModify 123voidExplainDirectModify(ForeignScanState *node, ExplainState *es); 为远程服务器上的直接修改打印额外的EXPLAIN输出。这个函数可以调用ExplainPropertyText和相关函数来为EXPLAIN输出增加域。es中的标志域可以被用来判断要打印什么，并且在EXPLAIN ANALYZE情况中可以观察ForeignScanState节点的状态来提供运行时统计信息。 如果ExplainDirectModify指针被设置为NULL，EXPLAIN期间不会打印出额外的信息。 ANALYZE 相关FDW回调函数 AnalyzeForeignTable 1234boolAnalyzeForeignTable (Relation relation, AcquireSampleRowsFunc *func, BlockNumber *totalpages); 当ANALYZE被执行在一个外部表上时会调用这个函数。如果FDW可以为这个外部表收集统计信息，它会返回true并提供一个函数指针，该函数将将从func中的表上收集采样行，外加totalpages中页面中的表尺寸估计值。否则，返回false。 如果FDW不支持为任何表收集统计信息，AnalyzeForeignTable指针可以被设置为NULL。 如果提供，采样收集函数必须具有签名 AcquireSampleRowsFunc 1234567intAcquireSampleRowsFunc(Relation relation, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows); 应该从该表上收集最多targrows行的一个随机采样并将它存放到调用者提供的rows数组中。实际被收集的行的数量必须被返回。另外，将表中有效行和死亡行的总数存储到输出参数totalrows和totaldeadrows中（如果FDW没有死亡行的概念，将totaldeadrows设置为 0 ）。 IMPORT FOREIGN SCHEMA 回调函数12List *ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid); 取得一个外部表创建命令的列表。在执行IMPORT FOREIGN SCHEMA时会调用这个函数，并且会把该语句的解析树以及要使用的外部服务器的 OID 传递给它。它应该返回一个 C 字符串的列表，每一个必须包含一个CREATE FOREIGN TABLE命令。这些命令将被核心服务器所解析和执行。 在ImportForeignSchemaStmt结构中，remote_schema是要从其中导入这些表的远程模式的名称。list_type标识如何过滤表名：FDW_IMPORT_SCHEMA_ALL表示该远程模式中的所有表都应该被导入（这种情况下table_list为空），FDW_IMPORT_SCHEMA_LIMIT_TO表示只包括table_list中列出的表，而FDW_IMPORT_SCHEMA_EXCEPT则表示排除table_list中列出的表。options是一个用于该导入处理的选项列表。选项的含义由 FDW 决定。例如，一个 FDW 可以用一个选项来定义是否应该导入列的NOT NULL属性。这些选项不需要与那些 FDW 支持的数据库对象选项有什么关系。 FDW 可能会忽略ImportForeignSchemaStmt的local_schema域，因为核心服务器会自动地向解析好的CREATE FOREIGN TABLE命令中插入本地模式的名称。 FDW 也不必担心实现list_type以及table_list所指定的过滤，因为核心服务器将自动根据那些选项跳过为被排除的表所返回的命令。不过，起初就避免为被排除的表创建命令当然更好。函数IsImportableForeignTable()可以用来测试一个给定的外部表名是否能通过该过滤器。 如果 FDW 不支持导入表定义，ImportForeignSchema指针可以被设置为NULL。 并行执行 回调函数ForeignScan节点可以选择支持并行执行。一个并行的 ForeignScan将在多个进程中执行， 并且在相互合作的进程中每个行必须只被返回一次。要做到这样， 进程可以通过动态共享内存的固定尺寸块来协作。并不保证在每一个进程中这部份共享内存都被映射到相同的地址， 因此必须不能包含指针。下面的函数都是可选的，但是如果要支持并行执行需要提供大多数函数。 IsForeignScanParallelSafe123boolIsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte); 测试一个扫描是否可以在一个并行工作者中被执行。只有当规划器相信可以使用并行计划时才会调用这个函数，如果该扫描在并行工作者中可以安全运行这个函数应该返回真。如果远程数据源具有事务语义，情况通常都不是这样，除非工作者到数据的连接能够以某种方式共享与领导者相同的事务环境。 如果没有定义这个函数，则假定该扫描必须被放置在并行领导者中。注意返回真并不意味着该扫描本身可以被并行完成，只是说明该扫描可以在一个并行工作者中执行。因此，即便当不支持并行执行时，定义这个方法也是有用的。 EstimateDSMForeignScan 12SizeEstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt); 估算并行操作所需的动态共享内存的数量。这可能比实际要用的数量更大，但是绝不能更小。返回值的单位是字节。该函数是可选的，如果不需要可以省略；但是如果省略它， 接下来的三个函数也必须省略，因为没有分配共享内存将给FDW使用。 InitializeDSMForeignScan 123voidInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt, void *coordinate); 初始化并行操作所需的动态共享内存。coordinate指向共享内存区域， 其大小等于EstimateDSMForeignScan的返回值。 该函数是可选的，如果不需要可以省略。 ReInitializeDSMForeignScan 123voidReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt, void *coordinate); 当外部扫描计划节点即将被重新扫描时，重新初始化并行操作所需的动态共享内存。该函数是可选的，如果不需要可以省略。推荐的做法是此函数仅重置共享状态， 而ReScanForeignScan函数仅重置本地状态。目前， 这个函数会在ReScanForeignScan之前调用，但最好不要依赖这个顺序。 InitializeWorkerForeignScan 123voidInitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc, void *coordinate); 基于InitializeDSMForeignScan期间领导者设置的共享状态初始化并行工作者的本地状态。这个函数是可选的， 如果不需要可以省略。 ShutdownForeignScan 12voidShutdownForeignScan(ForeignScanState *node); 预计节点将不会执行完成时释放资源。这在所有情况下都不被调用；有时， EndForeignScan可能会在没有先调用此函数的情况下调用。由于并行查询使用的DSM段在调用此回调后即被销毁， 因此希望在DSM段消失之前采取某些操作的外部数据包装器应实现此方法。 用于路径重新参数化 的回调函数 ReparameterizeForeignPathByChild 123List *ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private, RelOptInfo *child_rel); 在将由给定子关系child_rel的最顶层父级参数化的路径转换为由子关系参数化时，调用此函数。该函数用于重新参数化任何路径或转换保存在给定ForeignPath节点的fdw_private 成员中的任何表达式。回调根据需要使用reparameterize_path_by_child，adjust_appendrel_attrs也可以adjust_appendrel_attrs_multilevel。","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"}]},{"title":"学习PostgreSQL的FDW(#3)-其他函数说明 I","slug":"learn_about_pgfdw_part3","date":"2018-08-07T09:47:21.871Z","updated":"2018-08-09T08:17:19.893Z","comments":true,"path":"2018/08/07/learn_about_pgfdw_part3/","link":"","permalink":"https://oyo-byte.github.io/2018/08/07/learn_about_pgfdw_part3/","excerpt":"","text":"上两篇文章主要介绍了实现FDW的7个必须实现的扫描相关的回调函数，学习PostgreSQL的FDW(#1)，学习PostgreSQL的FDW(#2)-源码跟踪，这边就继续说说其余32个回调函数 用于扫描外部连接的回调函数如果一个 FDW 支持远程执行外部连接（而不是先把两个表的数据取到本地然后做本地连接），它应该提供这个回调函数:1234567voidGetForeignJoinPaths (PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *outerrel, RelOptInfo *innerrel, JoinType jointype, JoinPathExtraData *extra); 它为两个（或更多）同属于一台外部服务器的外部表的连接创建可能的访问路径。这个可选的函数会在查询规划过程中被调用。和GetForeignPaths一样，这个函数应该为提供的joinrel生成ForeignPath路径，并且调用add_path把这些路径加入到该连接应该考虑的路径集合中。但是和GetForeignPaths不一样的是，不需要这个函数产生最少一个路径，因为涉及本地连接的路径总是可用的。 注意的是，对于相同的连接关系，将会重复调用此函数来生成内外关系的不同组合。FDW需要负责最小化其中重复的工作。 如果一个ForeignPath路径被选中用于该连接，它将在整个连接处理中存在，为其中的成分表和子连接产生的路径将不会被使用。后续对该连接路径的处理大部分和扫描单个外部表的路径一样。一点不同是ForeignScan计划节点的scanrelid应该被设置为零，因为它表示的不是单个关系，而是用ForeignScan节点的fs_relids属性来表示被连接的关系集合（fs_relids会被核心规划器代码自动设置，不需要由 FDW 填充）。另一点不同是，由于一个远程连接的列的列表无法在系统目录中找到，FDW必须用一个合适的TargetEntry节点列表来填充fdw_scan_tlist，表示运行时它返回的元组中提供的列的集合。 用于规划扫描/连接 后处理的回调函数如果一个FDW支持执行远程的扫描/连接 后处理，例如远程聚集，应该事先这个回调函数：123456voidGetForeignUpperPaths(PlannerInfo *root, UpperRelationKind stage, RelOptInfo *input_rel, RelOptInfo *output_rel, void *extra); 为上层关系处理创建可能的访问路径，这是规划器针对所有扫描/连接后查询处理的术语，例如聚集、窗口函数、排序和表更新。在查询规划期间会调用这个可选的函数。当前，只有当该查询中涉及的所有基本关系都属于同一个 FDW 时才会调用这个函数。这个函数应该让 FDW 知道如何远程执行的任何扫描/连接 后处理生成ForeignPath路径，并且调用add_path把这些路径加入到上层关系中。就GetForeignJoinPaths来说，并不要求这个函数在创建任何路径时都能成功，因为涉及本地处理的路径总是可行的。 stage参数表示当前正在考虑的是哪一个扫描/连接后处理步骤。output_rel是接收表示这一个步骤的路径的上层关系，而input_rel是表示这个步骤输入的关系。extra参数提供了其他详细信息。目前，它仅能设置成UPPERREL_PARTIAL_GROUP_AGG或UPPERREL_GROUP_AGG，在这种情况下，它指向的是GroupPathExtraData结构体。（注意被加入到output_rel中的ForeignPath路径通常对input_rel的路径没有直接的依赖，因为它们的处理被认为是在外部处理的。不过，检查为前一个处理步骤生成的路径有助于避免冗余的规划工作）。 使用gdb追踪调用情况123456789101112131415161718192021222324(gdb) b postgresGetForeignUpperPathsBreakpoint 1 at 0x7f2cea563a20: file postgres_fdw.c, line 5437.(gdb) cContinuing.Breakpoint 1, postgresGetForeignUpperPaths (root=0xf7ce50, stage=UPPERREL_GROUP_AGG, input_rel=0xf7d3d0, output_rel=0x1063910, extra=0x7ffc84ff94e0) at postgres_fdw.c:54375437 if (!input_rel-&gt;fdw_private ||(gdb) bt#0 postgresGetForeignUpperPaths (root=0xf7ce50, stage=UPPERREL_GROUP_AGG, input_rel=0xf7d3d0, output_rel=0x1063910, extra=0x7ffc84ff94e0) at postgres_fdw.c:5437#1 0x00000000006807bf in create_ordinary_grouping_paths (root=root@entry=0xf7ce50, input_rel=input_rel@entry=0xf7d3d0, grouped_rel=grouped_rel@entry=0x1063910, agg_costs=agg_costs@entry=0x7ffc84ff94b0, gd=gd@entry=0x0, extra=extra@entry=0x7ffc84ff94e0, partially_grouped_rel_p=partially_grouped_rel_p@entry=0x7ffc84ff9488) at planner.c:4059#2 0x00000000006831e9 in create_grouping_paths (gd=0x0, agg_costs=0x7ffc84ff94b0, target_parallel_safe=true, target=0x1063768, input_rel=0xf7d3d0, root=0xf7ce50) at planner.c:3783#3 grouping_planner (root=root@entry=0xf7ce50, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:2037#4 0x0000000000684218 in subquery_planner (glob=glob@entry=0xf7cdc0, parse=parse@entry=0xf7c6a8, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:966#5 0x0000000000685236 in standard_planner (parse=0xf7c6a8, cursorOptions=256, boundParams=0x0) at planner.c:405#6 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0xf7c6a8, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809#7 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875#8 0x0000000000721cda in exec_simple_query (query_string=0xf7b810 \"select count(*) from t_fdw ;\") at postgres.c:1050#9 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0xfa5528, dbname=0xfa5410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#10 0x000000000047a861 in BackendRun (port=0xf9d3f0) at postmaster.c:4361#11 BackendStartup (port=0xf9d3f0) at postmaster.c:4033#12 ServerLoop () at postmaster.c:1706#13 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0xf763c0) at postmaster.c:1379#14 0x000000000047b2a1 in main (argc=3, argv=0xf763c0) at main.c:228 更新外部表的回调函数 回调函数 作用 AddForeignUpdateTargets 保证FDW能够找到要更新或删除的准确行 PlanForeignModify 执行外部表上插入、更新或删除所需的任何附加规划动作 BeginForeignModify 开始执行一个外部表修改操作，执行任何先于实际表修改的初始化工作 ExecForeignInsert 插入一个元组到外部表 ExecForeignUpdate 更新外部表中的一个元组 ExecForeignDelete 从外部表删除一个元组 EndForeignModify 结束表更新并释放资源 BeginForeignInsert 开始在外表上执行插入操作(分区表或COPY FROM命令)，在实际插入之前执行所需的任何初始化 EndForeignInsert 结束表插入并释放资源(分区表或COPY FROM命令) IsForeignRelUpdatable 报告指定的外部表支持哪些更新操作 PlanDirectModify 决定在远程服务器上执行直接修改是否安全 BeginDirectModify 准备在远程服务器上执行一次直接修改，执行直接修改所需的任何初始化工作 IterateDirectModify 执行直接修改操作 EndDirectModify 在远程服务器上的直接修改后进行清理 如果一个FDW支持可写的外部表，根据FDW的需要和功能，应该提供以下某些或者全部回调函数： AddForeignUpdateTargets 1234voidAddForeignUpdateTargets(Query *parsetree, RangeTblEntry *target_rte, Relation target_relation); UPDATE和DELETE操作是在之前由表扫描函数取出的行上被执行的。FDW可能需要额外的信息（例如一个行ID或主键列的值）来保证它能够找到要更新或删除的准确行。要支持这些要求，这个函数可以向列列表中增加额外的隐藏或“junk”的目标列，它们在一个UPDATE或DELETE期间会被从外部表中获取。 要做到这一点，向parsetree-&gt;targetList中增加TargetEntry项，它们包含要被获取的额外值的表达式。每一个这样的项必须被标记为resjunk = true，并且必须有一个可区分的resname用于在执行期间标识它。请避免使用匹配ctidN、wholerow或wholerowN的名字，因为核心系统可能会生成使用这些名字的junk列。如果额外的表达式比简单的Vars更复杂，在将它们添加到目标列表之前，必须通过eval_const_expressions运行它们。 这个函数在重写器中被调用，而不是在规划器中，因此可用的信息与在规划例程中的有点区别。parsetree是UPDATE或DELETE命令的分析树，而target_rte和target_relation描述目标外部表。 如果AddForeignUpdateTargets指针被设置为NULL，则不会有额外的目标表达式被加入（这将使得我们不可能实现DELETE操作，而UPDATE则还有可能是可行的，前提是FDW依赖一个未改变的主键来标识行）。 PlanForeignModify 12345List *PlanForeignModify(PlannerInfo *root, ModifyTable *plan, Index resultRelation, int subplan_index); 执行外部表上插入、更新或删除所需的任何附加规划动作。这个函数生成FDW私有信息，该信息将被附加到执行该更新动作的ModifyTable计划节点。这个私有信息的形式必须是一个List，并将会在执行阶段被传递给BeginForeignModify。 root是规划器关于该查询的全局信息。plan是ModifyTable计划节点，它除了fdwPrivLists属性之外是完整的。resultRelation通过目标外部表的范围表索引来标识它。subplan_index标识这是ModifyTable计划节点的哪个目标，从零开始计数；如果你希望索引到plan-&gt;plans或其他plan节点的子结构中，请使用它。 如果PlanForeignModify指针被设置为NULL，则不会有额外的计划时动作被执行，并且传递给BeginForeignModify的fdw_private列表也将为 NIL。 BeginForeignModify 123456voidBeginForeignModify (ModifyTableState *mtstate, ResultRelInfo *rinfo, List *fdw_private, int subplan_index, int eflags); 开始执行一个外部表修改操作。这个函数在执行器启动期间被调用。它应该执行任何先于实际表修改的初始化工作。随后，ExecForeignInsert、ExecForeignUpdate或ExecForeignDelete将被为每一个将被插入、更新或删除的元组调用。 mtstate是要被执行的ModifyTable计划节点的状态信息；通过这个结构可以得到关于规划和执行阶段的全局数据。rinfo是描述目标外部表的ResultRelInfo结构（ResultRelInfo的ri_FdwState属性用于FDW来存储它在此操作中需要的任何私有状态）。fdw_private包含PlanForeignModify生成的私有数据。subplan_index标识这是ModifyTable计划节点的哪个目标。eflags包含描述执行器对该计划节点操作模式的标志位。 注意当(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)为真，这个函数不应执行任何外部可见的动作；它只应该做最少的工作来创建ExplainForeignModify和EndForeignModify可用的节点状态。 如果BeginForeignModify指针被设置为NULL，在执行器启动期间将不会采取任何动作。 ExecForeignInsert 12345TupleTableSlot *ExecForeignInsert(EState *estate, ResultRelInfo *rinfo, TupleTableSlot *slot, TupleTableSlot *planSlot); 插入一个元组到外部表。estate是查询的全局执行状态。rinfo是描述目标外部表的ResultRelInfo结构。slot包含要被插入的元组；它将匹配外部表的行类型定义。planSlot包含由ModifyTable计划节点的子计划生成的元组；它与slot不同，它可能包含额外的“junk”列（INSERT情况通常不关心planSlot，但是为了完整性还是在这里提供它）。 返回值可以是一个包含实际被插入的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有插入行（还是触发器的结果）。被传入的slot可以被重用于这个目的。 在返回槽中的数据只有在INSERT查询具有一个RETURNING子句或者外部表具有一个AFTER ROW触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据RETURNING子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，否则查询报告的行计数将会是错误的。 如果ExecForeignInsert指针被设置为NULL，尝试向外部表插入将会失败并报告一个错误消息。 ExecForeignUpdate 12345TupleTableSlot *ExecForeignUpdate(EState *estate, ResultRelInfo *rinfo, TupleTableSlot *slot, TupleTableSlot *planSlot); 更新外部表中的一个元组。estate是查询的全局执行状态。rinfo是描述目标外部表的ResultRelInfo结构。slot包含元组的新数据；它将匹配外部表的行类型定义。planSlot包含由ModifyTable计划节点的子计划生成的元组；它与slot不同，它可能包含额外的“junk”列。特殊地，任何AddForeignUpdateTargets所要求的junk列在这个槽中都是有效的。 返回值可以是一个包含实际被更新的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有更新行（还是触发器的结果）。被传入的slot可以被重用于这个目的。 在返回槽中的数据只有在UPDATE查询具有一个RETURNING子句或者外部表具有一个AFTER ROW触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据RETURNING子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，否则查询报告的行计数将会是错误的。 如果ExecForeignUpdate指针被设置为NULL，尝试更新外部表将会失败并报告一个错误消息。 ExecForeignDelete 12345TupleTableSlot *ExecForeignDelete(EState *estate, ResultRelInfo *rinfo, TupleTableSlot *slot, TupleTableSlot *planSlot); 从外部表删除一个元组。estate是查询的全局执行状态。rinfo是描述目标外部表的ResultRelInfo结构。slot在调用时不包含任何有用的东西，但是可以被用于保持被返回的元组。planSlot包含由ModifyTable计划节点的子计划生成的元组；特殊地，它将携带AddForeignUpdateTargets所要求的任意junk列。junk列被用来标识要被删除的元组。 返回值可以是一个包含实际被删除的数据的槽，或者为 NULL 表示实际没有删除行（还是触发器的结果）。被传入的slot可以被重用于这个目的。 在返回槽中的数据只有在DELETE查询具有一个RETURNING子句或者外部表具有一个AFTER ROW触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据RETURNING子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，否则查询报告的行计数将会是错误的。 如果ExecForeignDelete指针被设置为NULL，尝试从外部表中删除将会失败并报告一个错误消息。 EndForeignModify 123voidEndForeignModify(EState *estate, ResultRelInfo *rinfo); 结束表更新并释放资源。通常释放palloc的内存并不重要，但是打开的文件和到远程服务器的连接等应当被清除。 如果EndForeignModify指针被设置为NULL，在执行器关闭期间不会采取任何动作。 通过INSERT或COPY FROM插入分区表的元组将路由到分区。如果FDW支持可路由的外表分区，它还应提供以下回调函数。在外部表上执行COPY FROM时也会调用这些函数： BeginForeignInsert 123voidBeginForeignInsert(ModifyTableState *mtstate, ResultRelInfo *rinfo); 开始在外表上执行插入操作。在将第一个元组插入到外表中之前，当它是为元组路由选择的分区和在COPY FROM命令中指定的目标时，就会调用此例程。它应该在实际插入之前执行所需的任何初始化。随后，将调用ExecForeignInsert以将每个元组插入到外表中。 mtstate是要被执行的ModifyTable计划节点的状态信息；通过这个结构可以得到关于规划和执行阶段的全局数据。rinfo是描述目标外部表的ResultRelInfo结构（ResultRelInfo的ri_FdwState属性用于FDW来存储它在此操作中需要的任何私有状态）。 当通过COPY FROM命令调用此方法时，不提供mtstate中与计划相关的全局数据，并且随后为每个插入的元组调用的ExecForeignInsert的planSlot参数为NULL，无论外表是为元组路由选择的分区还是在命令中指定的目标。 如果BeginForeignInsert指针设置为NULL，则不会对初始化执行任何操作。 EndForeignInsert 123voidEndForeignInsert(EState *estate, ResultRelInfo *rinfo); 结束表插入并释放资源。通常释放palloc的内存并不重要，但是打开的文件和到远程服务器的连接等应当被清除。 如果EndForeignInsert指针被设置为NULL，在执行器关闭期间不会采取任何动作。 IsForeignRelUpdatable 12intIsForeignRelUpdatable(Relation rel); 报告指定的外部表支持哪些更新操作。返回值应该是一个规则事件编号的位掩码，它指示了哪些操作被外部表支持，它使用CmdType枚举，即：(1 &lt;&lt; CMD_UPDATE) = 4表示UPDATE、 (1 &lt;&lt; CMD_INSERT) = 8表示INSERT以及 (1 &lt;&lt; CMD_DELETE) = 16表示DELETE。 如果IsForeignRelUpdatable指针被设置为NULL，而FDW提供了ExecForeignInsert、ExecForeignUpdate或ExecForeignDelete，则外部表分别被假定为可插入、可更新或可删除。 一些对于外部表的插入、更新和删除可以通过实现另一组接口来优化。普通的插入、更新和删除接口会从远程服务器取得行，然后一次修改其中一行。在某些情况下，这种逐行的方式是必要的，但是可能效率不高。如果有可能让外部服务器判断哪些行可以直接修改而无需先检索它们并且没有本地触发器会影响该操作，那么可以让整个操作在远程服务器上执行。下面介绍的接口能让这种做法变成可能。 PlanDirectModify 12345boolPlanDirectModify(PlannerInfo *root, ModifyTable *plan, Index resultRelation, int subplan_index); 决定在远程服务器上执行直接修改是否安全。如果安全，执行所需的规划动作然后返回true,否则返回false。这个可选的函数在查询规划期间被调用。如果这个函数成功，在执行阶段将会调用BeginDirectModify、IterateDirectModify和EndDirectModify。否则，对表的修改将采用上文描述的表更新函数来执行。参数和PlanForeignModify的相同。 要在远程服务器上执行直接修改，这个函数必须用一个ForeignScan计划节点（它在远程服务器上执行直接修改）重写目标子计划。ForeignScan的operation域必须被合适地设置为CmdType枚举值，即CMD_UPDATE表示UPDATE、CMD_INSERT表示INSERT而CMD_DELETE表示DELETE。 如果PlanDirectModify指针被设置为NULL，不会尝试在远程服务器上执行直接修改。 BeginDirectModify 123voidBeginDirectModify(ForeignScanState *node, int eflags); 准备在远程服务器上执行一次直接修改。这个函数会在执行器启动时被调用。它应该执行直接修改所需的任何初始化工作（应该在第一次IterateDirectModify调用之前完成）。ForeignScanState节点已经被创建，但是它的fdw_state属性仍然为 NULL。有关要被修改的表的信息可以访问ForeignScanState节点（具体地，从底层的ForeignScan计划节点，它包含了PlanDirectModify提供的 FDW-私有信息）。eflags包含描述执行器对于这个计划节点操作模式的标志位。 注意当(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)为真时，这个函数不应该执行任何外部可见的动作。它应当只做最少的工作让该节点状态对ExplainDirectModify和EndDirectModify有效。 如果BeginDirectModify指针被设置为NULL，不会尝试在远程服务器上执行直接修改。 IterateDirectModify 12TupleTableSlot *IterateDirectModify(ForeignScanState *node); 当INSERT、UPDATE或者DELETE查询没有RETURNING子句时，完成远程服务器上的直接修改后返回 NULL。当查询有该子句时，取出一个包含RETURNING计算所需数据的结果，用一个元组表槽返回它（节点的ScanTupleSlot应被用于这一目的）。实际被插入、更新或者删除的数据必须被存储在该节点的EState的es_result_relation_info-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple中。如果没有更多行可用，则返回 NULL。注意这个函数会在一个短期生存的内存上下文中被调用，该上下文会在两次调用之间被重置。如果需要一个长期存在的存储，可以在BeginDirectModify中创建一个内存上下文，或者使用该节点的EState中的es_query_cxt。 如果提供了fdw_scan_tlist目标列表，则被返回的行必须匹配它。否则，被返回的行必须匹配被更新的外部表的行类型。如果选择优化掉RETURNING计算不需要的列，应该在这些列的位置上插入空值，或者生成一个忽略这些列的fdw_scan_tlist列表。 不管该查询是否具有RETURNING子句，查询所报告的行计数必须由 FDW 本身增加。当查询没有该子句时，FDW 还必须为EXPLAIN ANALYZE情况下的ForeignScanState节点增加行计数。 如果IterateDirectModify指针被设置为NULL，不会尝试在远程服务器上执行直接修改。 EndDirectModify 12voidEndDirectModify(ForeignScanState *node); 在远程服务器上的直接修改后进行清理。通常释放用 palloc 分配的内存并不重要，但是诸如打开的文件和到远程服务器的连接应该被清除。 如果EndDirectModify指针被设置为NULL，不会尝试在远程服务器上执行直接修改。 在外部表插入一条数据insert into t_fdw values(11,&#39;1&#39;,&#39;2&#39;);执行insert语句的调用顺序 使用gdb追踪123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325(gdb) b postgresAddForeignUpdateTargetsBreakpoint 1 at 0x7fee88320260: file postgres_fdw.c, line 1541.(gdb) b postgresPlanForeignModifyBreakpoint 2 at 0x7fee883203a0: file postgres_fdw.c, line 1579.(gdb) b postgresBeginForeignModifyBreakpoint 3 at 0x7fee88321e20: file postgres_fdw.c, line 1698.(gdb) b postgresExecForeignInsertBreakpoint 4 at 0x7fee88323000: file postgres_fdw.c, line 1750.(gdb) b postgresExecForeignUpdateBreakpoint 5 at 0x7fee88322e40: file postgres_fdw.c, line 1814.(gdb) b postgresExecForeignDeleteBreakpoint 6 at 0x7fee88322c80: file postgres_fdw.c, line 1890.(gdb) b postgresEndForeignModifyBreakpoint 7 at 0x7fee88321010: file postgres_fdw.c, line 1965.(gdb) b postgresBeginForeignInsertBreakpoint 8 at 0x7fee88321c10: file postgres_fdw.c, line 1982.(gdb) b postgresEndForeignInsertBreakpoint 9 at 0x7fee88320ff0: file postgres_fdw.c, line 2074.(gdb) b postgresIsForeignRelUpdatableBreakpoint 10 at 0x7fee8831e900: file postgres_fdw.c, line 2089.(gdb) b postgresPlanDirectModifyBreakpoint 11 at 0x7fee883213b0: file postgres_fdw.c, line 2167.(gdb) b postgresBeginDirectModifyBreakpoint 12 at 0x7fee8831fd80: file postgres_fdw.c, line 2360.(gdb) b postgresIterateDirectModifyBreakpoint 13 at 0x7fee883227f0: file postgres_fdw.c, line 2479.(gdb) b postgresEndDirectModifyBreakpoint 14 at 0x7fee8831fb60: file postgres_fdw.c, line 2523.# 切换至psql，执行插入语句fdw=# insert into t_fdw values(11,'1','2');# （挂起）# 切换回gdb(gdb) cContinuing.Breakpoint 11, postgresPlanDirectModify (root=0x2113f08, plan=0x2115680, resultRelation=1, subplan_index=0) at postgres_fdw.c:21672167 &#123;(gdb) bt#0 postgresPlanDirectModify (root=0x2113f08, plan=0x2115680, resultRelation=1, subplan_index=0) at postgres_fdw.c:2167#1 0x00000000006790a1 in make_modifytable (epqParam=&lt;optimized out&gt;, onconflict=&lt;optimized out&gt;, rowMarks=&lt;optimized out&gt;, returningLists=&lt;optimized out&gt;, withCheckOptionLists=&lt;optimized out&gt;, subroots=&lt;optimized out&gt;, subplans=&lt;optimized out&gt;, resultRelations=&lt;optimized out&gt;, partColsUpdated=&lt;optimized out&gt;, partitioned_rels=&lt;optimized out&gt;, nominalRelation=&lt;optimized out&gt;, canSetTag=&lt;optimized out&gt;, operation=&lt;optimized out&gt;, root=&lt;optimized out&gt;) at createplan.c:6680#2 create_modifytable_plan (best_path=0x20635e0, root=&lt;optimized out&gt;) at createplan.c:2479#3 create_plan_recurse (root=root@entry=0x2113f08, best_path=0x20635e0, flags=flags@entry=1) at createplan.c:492#4 0x0000000000679dc9 in create_plan (root=root@entry=0x2113f08, best_path=&lt;optimized out&gt;) at createplan.c:327#5 0x0000000000685264 in standard_planner (parse=0x20636f0, cursorOptions=256, boundParams=0x0) at planner.c:412#6 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0x20636f0, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809#7 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875#8 0x0000000000721cda in exec_simple_query (query_string=0x2062810 \"insert into t_fdw values(11,'1','2');\") at postgres.c:1050#9 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x208c528, dbname=0x208c410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#10 0x000000000047a861 in BackendRun (port=0x20843f0) at postmaster.c:4361#11 BackendStartup (port=0x20843f0) at postmaster.c:4033#12 ServerLoop () at postmaster.c:1706#13 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x205d3c0) at postmaster.c:1379#14 0x000000000047b2a1 in main (argc=3, argv=0x205d3c0) at main.c:228(gdb) finishRun till exit from #0 postgresPlanDirectModify (root=0x2113f08, plan=0x2115680, resultRelation=1, subplan_index=0) at postgres_fdw.c:2167make_modifytable (epqParam=&lt;optimized out&gt;, onconflict=&lt;optimized out&gt;, rowMarks=&lt;optimized out&gt;, returningLists=&lt;optimized out&gt;, withCheckOptionLists=&lt;optimized out&gt;, subroots=&lt;optimized out&gt;, subplans=&lt;optimized out&gt;, resultRelations=&lt;optimized out&gt;, partColsUpdated=&lt;optimized out&gt;, partitioned_rels=&lt;optimized out&gt;, nominalRelation=&lt;optimized out&gt;, canSetTag=&lt;optimized out&gt;, operation=&lt;optimized out&gt;, root=&lt;optimized out&gt;) at createplan.c:66816681 if (direct_modify)Value returned is $15 = false(gdb) finishRun till exit from #0 make_modifytable (epqParam=&lt;optimized out&gt;, onconflict=&lt;optimized out&gt;, rowMarks=&lt;optimized out&gt;, returningLists=&lt;optimized out&gt;, withCheckOptionLists=&lt;optimized out&gt;, subroots=&lt;optimized out&gt;, subplans=&lt;optimized out&gt;, resultRelations=&lt;optimized out&gt;, partColsUpdated=&lt;optimized out&gt;, partitioned_rels=&lt;optimized out&gt;, nominalRelation=&lt;optimized out&gt;, canSetTag=&lt;optimized out&gt;, operation=&lt;optimized out&gt;, root=&lt;optimized out&gt;) at createplan.c:6681Breakpoint 2, postgresPlanForeignModify (root=0x2113f08, plan=plan@entry=0x2115680, resultRelation=1, subplan_index=subplan_index@entry=0) at postgres_fdw.c:15791579 &#123;(gdb) bt#0 postgresPlanForeignModify (root=0x2113f08, plan=plan@entry=0x2115680, resultRelation=1, subplan_index=subplan_index@entry=0) at postgres_fdw.c:1579#1 0x0000000000677001 in make_modifytable (epqParam=&lt;optimized out&gt;, onconflict=&lt;optimized out&gt;, rowMarks=&lt;optimized out&gt;, returningLists=&lt;optimized out&gt;, withCheckOptionLists=&lt;optimized out&gt;, subroots=&lt;optimized out&gt;, subplans=&lt;optimized out&gt;, resultRelations=&lt;optimized out&gt;, partColsUpdated=&lt;optimized out&gt;, partitioned_rels=&lt;optimized out&gt;, nominalRelation=&lt;optimized out&gt;, canSetTag=&lt;optimized out&gt;, operation=&lt;optimized out&gt;, root=&lt;optimized out&gt;) at createplan.c:6687#2 create_modifytable_plan (best_path=0x20635e0, root=&lt;optimized out&gt;) at createplan.c:2479#3 create_plan_recurse (root=root@entry=0x2113f08, best_path=0x20635e0, flags=flags@entry=1) at createplan.c:492#4 0x0000000000679dc9 in create_plan (root=root@entry=0x2113f08, best_path=&lt;optimized out&gt;) at createplan.c:327#5 0x0000000000685264 in standard_planner (parse=0x20636f0, cursorOptions=256, boundParams=0x0) at planner.c:412#6 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0x20636f0, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809#7 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875#8 0x0000000000721cda in exec_simple_query (query_string=0x2062810 \"insert into t_fdw values(12,'1','2');\") at postgres.c:1050#9 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x208c528, dbname=0x208c410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#10 0x000000000047a861 in BackendRun (port=0x20843f0) at postmaster.c:4361#11 BackendStartup (port=0x20843f0) at postmaster.c:4033#12 ServerLoop () at postmaster.c:1706#13 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x205d3c0) at postmaster.c:1379#14 0x000000000047b2a1 in main (argc=3, argv=0x205d3c0) at main.c:228(gdb) finishRun till exit from #0 postgresPlanForeignModify (root=0x2113f08, plan=plan@entry=0x2115680, resultRelation=1, subplan_index=subplan_index@entry=0) at postgres_fdw.c:15790x0000000000677001 in make_modifytable (epqParam=&lt;optimized out&gt;, onconflict=&lt;optimized out&gt;, rowMarks=&lt;optimized out&gt;, returningLists=&lt;optimized out&gt;, withCheckOptionLists=&lt;optimized out&gt;, subroots=&lt;optimized out&gt;, subplans=&lt;optimized out&gt;, resultRelations=&lt;optimized out&gt;, partColsUpdated=&lt;optimized out&gt;, partitioned_rels=&lt;optimized out&gt;, nominalRelation=&lt;optimized out&gt;, canSetTag=&lt;optimized out&gt;, operation=&lt;optimized out&gt;, root=&lt;optimized out&gt;) at createplan.c:66876687 fdw_private = fdwroutine-&gt;PlanForeignModify(subroot, node, rti, i);Value returned is $16 = (List *) 0x218b810(gdb) finishRun till exit from #0 0x0000000000677001 in make_modifytable (epqParam=&lt;optimized out&gt;, onconflict=&lt;optimized out&gt;, rowMarks=&lt;optimized out&gt;, returningLists=&lt;optimized out&gt;, withCheckOptionLists=&lt;optimized out&gt;, subroots=&lt;optimized out&gt;, subplans=&lt;optimized out&gt;, resultRelations=&lt;optimized out&gt;, partColsUpdated=&lt;optimized out&gt;, partitioned_rels=&lt;optimized out&gt;, nominalRelation=&lt;optimized out&gt;, canSetTag=&lt;optimized out&gt;, operation=&lt;optimized out&gt;, root=&lt;optimized out&gt;) at createplan.c:6687create_plan_recurse (root=root@entry=0x2113f08, best_path=&lt;optimized out&gt;, flags=flags@entry=1) at createplan.c:492492 plan = (Plan *) create_modifytable_plan(root,(gdb) finishRun till exit from #0 create_plan_recurse (root=root@entry=0x2113f08, best_path=&lt;optimized out&gt;, flags=flags@entry=1) at createplan.c:492create_plan (root=root@entry=0x2113f08, best_path=&lt;optimized out&gt;) at createplan.c:336336 if (!IsA(plan, ModifyTable))Value returned is $17 = (Plan *) 0x2115680(gdb) finishRun till exit from #0 create_plan (root=root@entry=0x2113f08, best_path=&lt;optimized out&gt;) at createplan.c:336standard_planner (parse=0x20636f0, cursorOptions=256, boundParams=0x0) at planner.c:418418 if (cursorOptions &amp; CURSOR_OPT_SCROLL)Value returned is $18 = (Plan *) 0x2115680(gdb) finishRun till exit from #0 standard_planner (parse=0x20636f0, cursorOptions=256, boundParams=0x0) at planner.c:418pg_plan_query (querytree=querytree@entry=0x20636f0, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:811811 if (log_planner_stats)Value returned is $19 = (PlannedStmt *) 0x218bb60(gdb) finishRun till exit from #0 pg_plan_query (querytree=querytree@entry=0x20636f0, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:8110x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875875 stmt = pg_plan_query(query, cursorOptions, boundParams);Value returned is $20 = (PlannedStmt *) 0x218bb60(gdb) finishRun till exit from #0 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:8750x0000000000721cda in exec_simple_query ( query_string=0x2062810 \"insert into t_fdw values(12,'1','2');\") at postgres.c:10501050 plantree_list = pg_plan_queries(querytree_list,Value returned is $21 = (List *) 0x218bc90(gdb) finishRun till exit from #0 0x0000000000721cda in exec_simple_query ( query_string=0x2062810 \"insert into t_fdw values(12,'1','2');\") at postgres.c:1050Breakpoint 10, postgresIsForeignRelUpdatable (rel=0x7feed1ad1358) at postgres_fdw.c:20892089 &#123;(gdb) bt#0 postgresIsForeignRelUpdatable (rel=0x7feed1ad1358) at postgres_fdw.c:2089#1 0x00000000005f0820 in CheckValidResultRel (resultRelInfo=resultRelInfo@entry=0x20885c0, operation=operation@entry=CMD_INSERT) at execMain.c:1187#2 0x00000000006123a8 in ExecInitModifyTable (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at nodeModifyTable.c:2242#3 0x00000000005f6838 in ExecInitNode (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at execProcnode.c:174#4 0x00000000005f11c5 in InitPlan (eflags=0, queryDesc=&lt;optimized out&gt;) at execMain.c:1049#5 standard_ExecutorStart (queryDesc=&lt;optimized out&gt;, eflags=0) at execMain.c:264#6 0x0000000000724d26 in ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:156#7 0x0000000000724f61 in PortalRunMulti (portal=portal@entry=0x20c7f10, isTopLevel=isTopLevel@entry=true, setHoldSnapshot=setHoldSnapshot@entry=false, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"\") at pquery.c:1286#8 0x0000000000725a1c in PortalRun (portal=portal@entry=0x20c7f10, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"\") at pquery.c:799#9 0x0000000000721bb7 in exec_simple_query (query_string=0x2062810 \"insert into t_fdw values(12,'1','2');\") at postgres.c:1122#10 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x208c528, dbname=0x208c410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#11 0x000000000047a861 in BackendRun (port=0x20843f0) at postmaster.c:4361#12 BackendStartup (port=0x20843f0) at postmaster.c:4033#13 ServerLoop () at postmaster.c:1706#14 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x205d3c0) at postmaster.c:1379#15 0x000000000047b2a1 in main (argc=3, argv=0x205d3c0) at main.c:228(gdb) finishRun till exit from #0 postgresIsForeignRelUpdatable (rel=0x7feed1ad1358) at postgres_fdw.c:2089CheckValidResultRel (resultRelInfo=resultRelInfo@entry=0x20885c0, operation=operation@entry=CMD_INSERT) at execMain.c:11861186 if (fdwroutine-&gt;IsForeignRelUpdatable != NULL &amp;&amp;Value returned is $22 = 28(gdb) finishRun till exit from #0 CheckValidResultRel (resultRelInfo=resultRelInfo@entry=0x20885c0, operation=operation@entry=CMD_INSERT) at execMain.c:1186ExecInitModifyTable (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at nodeModifyTable.c:22532253 if (resultRelInfo-&gt;ri_RelationDesc-&gt;rd_rel-&gt;relhasindex &amp;&amp;(gdb) finishRun till exit from #0 ExecInitModifyTable (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at nodeModifyTable.c:2253Breakpoint 3, postgresBeginForeignModify (mtstate=0x20888e0, resultRelInfo=0x20885c0, fdw_private=0x218b810, subplan_index=0, eflags=0) at postgres_fdw.c:16981698 &#123;(gdb) bt#0 postgresBeginForeignModify (mtstate=0x20888e0, resultRelInfo=0x20885c0, fdw_private=0x218b810, subplan_index=0, eflags=0) at postgres_fdw.c:1698#1 0x0000000000612458 in ExecInitModifyTable (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at nodeModifyTable.c:2280#2 0x00000000005f6838 in ExecInitNode (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at execProcnode.c:174#3 0x00000000005f11c5 in InitPlan (eflags=0, queryDesc=&lt;optimized out&gt;) at execMain.c:1049#4 standard_ExecutorStart (queryDesc=&lt;optimized out&gt;, eflags=0) at execMain.c:264#5 0x0000000000724d26 in ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(13,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:156#6 0x0000000000724f61 in PortalRunMulti (portal=portal@entry=0x20c7f10, isTopLevel=isTopLevel@entry=true, setHoldSnapshot=setHoldSnapshot@entry=false, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"\") at pquery.c:1286#7 0x0000000000725a1c in PortalRun (portal=portal@entry=0x20c7f10, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"\") at pquery.c:799#8 0x0000000000721bb7 in exec_simple_query (query_string=0x2062810 \"insert into t_fdw values(13,'1','2');\") at postgres.c:1122#9 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x208c528, dbname=0x208c410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#10 0x000000000047a861 in BackendRun (port=0x20843f0) at postmaster.c:4361#11 BackendStartup (port=0x20843f0) at postmaster.c:4033#12 ServerLoop () at postmaster.c:1706#13 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x205d3c0) at postmaster.c:1379#14 0x000000000047b2a1 in main (argc=3, argv=0x205d3c0) at main.c:228(gdb) finishRun till exit from #0 postgresBeginForeignModify (mtstate=0x20888e0, resultRelInfo=0x20885c0, fdw_private=0x218b810, subplan_index=0, eflags=0) at postgres_fdw.c:1698ExecInitModifyTable (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at nodeModifyTable.c:22312231 foreach(l, node-&gt;plans)(gdb) finishRun till exit from #0 ExecInitModifyTable (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at nodeModifyTable.c:22310x00000000005f6838 in ExecInitNode (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at execProcnode.c:174174 result = (PlanState *) ExecInitModifyTable((ModifyTable *) node,Value returned is $23 = (ModifyTableState *) 0x20888e0(gdb) finishRun till exit from #0 0x00000000005f6838 in ExecInitNode (node=node@entry=0x2115680, estate=estate@entry=0x2088380, eflags=eflags@entry=0) at execProcnode.c:174InitPlan (eflags=0, queryDesc=&lt;optimized out&gt;) at execMain.c:10541054 tupType = ExecGetResultType(planstate);Value returned is $24 = (PlanState *) 0x20888e0(gdb) finishRun till exit from #0 InitPlan (eflags=0, queryDesc=&lt;optimized out&gt;) at execMain.c:1054266 MemoryContextSwitchTo(oldcontext);(gdb) finishRun till exit from #0 standard_ExecutorStart (queryDesc=&lt;optimized out&gt;, eflags=0) at execMain.c:266ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:161161 ExecutorRun(queryDesc, ForwardScanDirection, 0L, true);(gdb) finishRun till exit from #0 ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:161Breakpoint 4, postgresExecForeignInsert (estate=0x2088380, resultRelInfo=0x20885c0, slot=0x2089628, planSlot=0x2089628) at postgres_fdw.c:17501750 &#123;(gdb) bt#0 postgresExecForeignInsert (estate=0x2088380, resultRelInfo=0x20885c0, slot=0x2089628, planSlot=0x2089628) at postgres_fdw.c:1750#1 0x0000000000610d8b in ExecInsert (mtstate=mtstate@entry=0x20888e0, slot=0x2089628, planSlot=planSlot@entry=0x2089628, estate=estate@entry=0x2088380, canSetTag=&lt;optimized out&gt;) at nodeModifyTable.c:346#2 0x0000000000612119 in ExecModifyTable (pstate=0x20888e0) at nodeModifyTable.c:2126#3 0x00000000005f000a in ExecProcNode (node=0x20888e0) at ../../../src/include/executor/executor.h:237#4 ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x218bcc0, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=false, operation=CMD_INSERT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x20888e0, estate=0x2088380) at execMain.c:1726#5 standard_ExecutorRun (queryDesc=0x21413a0, direction=&lt;optimized out&gt;, count=0, execute_once=&lt;optimized out&gt;) at execMain.c:363#6 0x0000000000724d3a in ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:161#7 0x0000000000724f61 in PortalRunMulti (portal=portal@entry=0x20c7f10, isTopLevel=isTopLevel@entry=true, setHoldSnapshot=setHoldSnapshot@entry=false, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"\") at pquery.c:1286#8 0x0000000000725a1c in PortalRun (portal=portal@entry=0x20c7f10, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"\") at pquery.c:799#9 0x0000000000721bb7 in exec_simple_query (query_string=0x2062810 \"insert into t_fdw values(12,'1','2');\") at postgres.c:1122#10 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x208c528, dbname=0x208c410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#11 0x000000000047a861 in BackendRun (port=0x20843f0) at postmaster.c:4361#12 BackendStartup (port=0x20843f0) at postmaster.c:4033#13 ServerLoop () at postmaster.c:1706#14 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x205d3c0) at postmaster.c:1379#15 0x000000000047b2a1 in main (argc=3, argv=0x205d3c0) at main.c:228(gdb) finishRun till exit from #0 postgresExecForeignInsert (estate=0x2088380, resultRelInfo=0x20885c0, slot=0x2089628, planSlot=0x2089628) at postgres_fdw.c:1750ExecInsert (mtstate=mtstate@entry=0x20888e0, slot=0x2089628, planSlot=planSlot@entry=0x2089628, estate=estate@entry=0x2088380, canSetTag=&lt;optimized out&gt;) at nodeModifyTable.c:351351 if (slot == NULL) /* \"do nothing\" */Value returned is $25 = (TupleTableSlot *) 0x2089628(gdb) finishRun till exit from #0 ExecInsert (mtstate=mtstate@entry=0x20888e0, slot=0x2089628, planSlot=planSlot@entry=0x2089628, estate=estate@entry=0x2088380, canSetTag=&lt;optimized out&gt;) at nodeModifyTable.c:3510x0000000000612119 in ExecModifyTable (pstate=0x20888e0) at nodeModifyTable.c:21262126 slot = ExecInsert(node, slot, planSlot,Value returned is $26 = (TupleTableSlot *) 0x0(gdb) finishRun till exit from #0 0x0000000000612119 in ExecModifyTable (pstate=0x20888e0) at nodeModifyTable.c:2126ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x218bcc0, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=false, operation=CMD_INSERT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x20888e0, estate=0x2088380) at execMain.c:17321732 if (TupIsNull(slot))Value returned is $27 = (TupleTableSlot *) 0x0(gdb) finishRun till exit from #0 ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x218bcc0, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=false, operation=CMD_INSERT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x20888e0, estate=0x2088380) at execMain.c:1732377 if (sendTuples)(gdb) finishRun till exit from #0 standard_ExecutorRun (queryDesc=0x21413a0, direction=&lt;optimized out&gt;, count=0, execute_once=&lt;optimized out&gt;) at execMain.c:377ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:166166 if (completionTag)(gdb) finishRun till exit from #0 ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"\") at pquery.c:166Breakpoint 7, postgresEndForeignModify (estate=0x2088380, resultRelInfo=0x20885c0) at postgres_fdw.c:19651965 PgFdwModifyState *fmstate = (PgFdwModifyState *) resultRelInfo-&gt;ri_FdwState;(gdb) bt#0 postgresEndForeignModify (estate=0x2088380, resultRelInfo=0x20885c0) at postgres_fdw.c:1965#1 0x0000000000612c7b in ExecEndModifyTable (node=0x20888e0) at nodeModifyTable.c:2664#2 0x00000000005f16ad in ExecEndPlan (estate=0x2088380, planstate=&lt;optimized out&gt;) at execMain.c:1612#3 standard_ExecutorEnd (queryDesc=0x21413a0) at execMain.c:495#4 0x0000000000724d90 in ProcessQuery (plan=&lt;optimized out&gt;, sourceText=0x2062810 \"insert into t_fdw values(12,'1','2');\", params=0x0, queryEnv=0x0, dest=0x218bcc0, completionTag=0x7ffd2229fcd0 \"INSERT 0 1\") at pquery.c:206#5 0x0000000000724f61 in PortalRunMulti (portal=portal@entry=0x20c7f10, isTopLevel=isTopLevel@entry=true, setHoldSnapshot=setHoldSnapshot@entry=false, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"INSERT 0 1\") at pquery.c:1286#6 0x0000000000725a1c in PortalRun (portal=portal@entry=0x20c7f10, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x218bcc0, altdest=altdest@entry=0x218bcc0, completionTag=completionTag@entry=0x7ffd2229fcd0 \"INSERT 0 1\") at pquery.c:799#7 0x0000000000721bb7 in exec_simple_query (query_string=0x2062810 \"insert into t_fdw values(12,'1','2');\") at postgres.c:1122#8 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x208c528, dbname=0x208c410 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#9 0x000000000047a861 in BackendRun (port=0x20843f0) at postmaster.c:4361#10 BackendStartup (port=0x20843f0) at postmaster.c:4033#11 ServerLoop () at postmaster.c:1706#12 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x205d3c0) at postmaster.c:1379#13 0x000000000047b2a1 in main (argc=3, argv=0x205d3c0) at main.c:228# 后续执行结束... 在外部表更新数据 update t_fdw set c1=&#39;11&#39; where id=11; 在外部表删除数据，使用gdb跟踪调用流程，发现和update语句的流程是一样的，查看相关代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* * postgresIterateDirectModify * Execute a direct foreign table modification */static TupleTableSlot *postgresIterateDirectModify(ForeignScanState *node)&#123; PgFdwDirectModifyState *dmstate = (PgFdwDirectModifyState *) node-&gt;fdw_state; EState *estate = node-&gt;ss.ps.state; ResultRelInfo *resultRelInfo = estate-&gt;es_result_relation_info; /* * If this is the first call after Begin, execute the statement. */ if (dmstate-&gt;num_tuples == -1) execute_dml_stmt(node); /* * If the local query doesn't specify RETURNING, just clear tuple slot. */ if (!resultRelInfo-&gt;ri_projectReturning) &#123; TupleTableSlot *slot = node-&gt;ss.ss_ScanTupleSlot; Instrumentation *instr = node-&gt;ss.ps.instrument; Assert(!dmstate-&gt;has_returning); /* Increment the command es_processed count if necessary. */ if (dmstate-&gt;set_processed) estate-&gt;es_processed += dmstate-&gt;num_tuples; /* Increment the tuple count for EXPLAIN ANALYZE if necessary. */ if (instr) instr-&gt;tuplecount += dmstate-&gt;num_tuples; return ExecClearTuple(slot); &#125; /* * Get the next RETURNING tuple. */ return get_returning_data(node);&#125;/* * Execute a direct UPDATE/DELETE statement. */static voidexecute_dml_stmt(ForeignScanState *node)&#123; PgFdwDirectModifyState *dmstate = (PgFdwDirectModifyState *) node-&gt;fdw_state; ExprContext *econtext = node-&gt;ss.ps.ps_ExprContext; int numParams = dmstate-&gt;numParams; const char **values = dmstate-&gt;param_values; /* * Construct array of query parameter values in text format. */ if (numParams &gt; 0) process_query_params(econtext, dmstate-&gt;param_flinfo, dmstate-&gt;param_exprs, values); /* * Notice that we pass NULL for paramTypes, thus forcing the remote server * to infer types for all parameters. Since we explicitly cast every * parameter (see deparse.c), the \"inference\" is trivial and will produce * the desired result. This allows us to avoid assuming that the remote * server has the same OIDs we do for the parameters' types. */ if (!PQsendQueryParams(dmstate-&gt;conn, dmstate-&gt;query, numParams, NULL, values, NULL, NULL, 0)) pgfdw_report_error(ERROR, NULL, dmstate-&gt;conn, false, dmstate-&gt;query); /* * Get the result, and check for success. * * We don't use a PG_TRY block here, so be careful not to throw error * without releasing the PGresult. */ dmstate-&gt;result = pgfdw_get_result(dmstate-&gt;conn, dmstate-&gt;query); if (PQresultStatus(dmstate-&gt;result) != (dmstate-&gt;has_returning ? PGRES_TUPLES_OK : PGRES_COMMAND_OK)) pgfdw_report_error(ERROR, dmstate-&gt;result, dmstate-&gt;conn, true, dmstate-&gt;query); /* Get the number of rows affected. */ if (dmstate-&gt;has_returning) dmstate-&gt;num_tuples = PQntuples(dmstate-&gt;result); else dmstate-&gt;num_tuples = atoi(PQcmdTuples(dmstate-&gt;result));&#125; 可以看到，postgresIterateDirectModify 调用了execute_dml_stmt执行直接UPDATE/DELETE语句的。","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"}]},{"title":"学习PostgreSQL的FDW(#2)-源码跟踪","slug":"learn_about_pgfdw_part2","date":"2018-08-07T02:15:45.504Z","updated":"2018-08-07T17:14:59.861Z","comments":true,"path":"2018/08/07/learn_about_pgfdw_part2/","link":"","permalink":"https://oyo-byte.github.io/2018/08/07/learn_about_pgfdw_part2/","excerpt":"","text":"上篇大概介绍了FDW必须实现的7个回调函数学习PostgreSQL的FDW(#1)，本篇将从源码跟踪，这7个回调函数的调用时机，以PostgreSQL11beta2的postgres_fdw为例，分析PostgreSQL在查询外部表时，究竟做了什么。 测试前准备IP为192.168.117.56的虚拟机安装了PostgreSQL10；IP为192.168.118.56的虚拟机安装了PostgreSQL11beta21234567891011121314151617181920212223testdb=# -- 在117.56中创建测试表testdb=# create table t_fdw(id int,c1 char(10),c2 varchar(10));CREATE TABLEtestdb=# insert into t_fdw values (1,'1','2');INSERT 0 1testdb=# insert into t_fdw values (2,'1','2');INSERT 0 1testdb=# insert into t_fdw values (3,'1','2');INSERT 0 1testdb=# insert into t_fdw values (4,'1','2');INSERT 0 1testdb=# insert into t_fdw values (5,'1','2');INSERT 0 1testdb=# insert into t_fdw values (6,'1','2');INSERT 0 1testdb=# insert into t_fdw values (7,'1','2');INSERT 0 1testdb=# insert into t_fdw values (8,'1','2');INSERT 0 1testdb=# insert into t_fdw values (9,'1','2');INSERT 0 1testdb=# insert into t_fdw values (10,'1','2');INSERT 0 1 1234567891011121314151617181920212223242526272829303132333435363738fdw=# -- 在118.56中创建postgres_fdw扩展fdw=# create extension postgres_fdw ;CREATE EXTENSIONfdw=# \\dx; List of installed extensions Name | Version | Schema | Description --------------+---------+------------+---------------------------------------------------- plpgsql | 1.0 | pg_catalog | PL/pgSQL procedural language postgres_fdw | 1.0 | public | foreign-data wrapper for remote PostgreSQL servers(2 rows)fdw=# -- 创建外部服务器fdw=# create server pg_117_56 foreign data wrapper postgres_fdw options (host '192.168.117.56',port '5432',dbname 'testdb');CREATE SERVERfdw=# \\des List of foreign servers Name | Owner | Foreign-data wrapper -----------+-------+---------------------- pg_117_56 | xdb | postgres_fdw(1 row)fdw=# --创建用户映射fdw=# create user MAPPING FOR PUBLIC server pg_117_56 options (user 'xdb',password 'test');CREATE USER MAPPINGfdw=# \\deu+ List of user mappings Server | User name | FDW options -----------+-----------+--------------------------------- pg_117_56 | public | (\"user\" 'xdb', password 'test')(1 row)fdw=# -- 创建外部表create foreign table t_fdw(id int, c1 char(10),c2 varchar(10)) server pg_117_56 options(schema_name 'public',table_name 't_fdw');CREATE FOREIGN TABLEfdw=# \\d List of relations Schema | Name | Type | Owner --------+-------+---------------+------- public | t_fdw | foreign table | xdb(1 row) 跟踪分析12345fdw=# select pg_backend_pid(); pg_backend_pid ---------------- 2382(1 row) 使用gdb跟踪查询过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449[root@localhost ~]# gdb -p 2382GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\".For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Attaching to process 2382...(gdb) # 设置断点(gdb) b postgresGetForeignRelSizeFunction \"postgresGetForeignRelSize\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (postgresGetForeignRelSize) pending.(gdb) b postgresGetForeignPathsFunction \"postgresGetForeignPaths\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 2 (postgresGetForeignPaths) pending.(gdb) b postgresGetForeignPlanFunction \"postgresGetForeignPlan\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 3 (postgresGetForeignPlan) pending.(gdb) b postgresBeginForeignScanFunction \"postgresBeginForeignScan\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 4 (postgresBeginForeignScan) pending.(gdb) b postgresIterateForeignScanFunction \"postgresIterateForeignScan\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 5 (postgresIterateForeignScan) pending.(gdb) b postgresReScanForeignScanFunction \"postgresReScanForeignScan\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 6 (postgresReScanForeignScan) pending.(gdb) b postgresEndForeignScanFunction \"postgresEndForeignScan\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 7 (postgresEndForeignScan) pending.# 切换到psql，执行查询语句fdw=# select * from t_fdw;# （挂起状态）# 切换回gdb(gdb) cContinuing.Breakpoint 1, postgresGetForeignRelSize (root=0x13342e8, baserel=0x13349e8, foreigntableid=16392) at postgres_fdw.c:522522 &#123;(gdb) bt#0 postgresGetForeignRelSize (root=0x13342e8, baserel=0x13349e8, foreigntableid=16392) at postgres_fdw.c:522#1 0x000000000065fde5 in set_foreign_size (rte=0x130f778, rel=0x13349e8, root=0x13342e8) at allpaths.c:839#2 set_rel_size (root=root@entry=0x13342e8, rel=rel@entry=0x13349e8, rti=rti@entry=1, rte=0x130f778) at allpaths.c:351#3 0x000000000066097d in set_base_rel_sizes (root=&lt;optimized out&gt;) at allpaths.c:281#4 make_one_rel (root=root@entry=0x13342e8, joinlist=joinlist@entry=0x1334e50) at allpaths.c:179#5 0x000000000067de9e in query_planner (root=root@entry=0x13342e8, tlist=tlist@entry=0x1334788, qp_callback=qp_callback@entry=0x67f290 &lt;standard_qp_callback&gt;, qp_extra=qp_extra@entry=0x7fff8c772f00) at planmain.c:259#6 0x0000000000681f43 in grouping_planner (root=root@entry=0x13342e8, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:1897#7 0x0000000000684218 in subquery_planner (glob=glob@entry=0x130fc38, parse=parse@entry=0x130f668, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:966#8 0x0000000000685236 in standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:405#9 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0x130f668, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809#10 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875#11 0x0000000000721cda in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1050#12 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#13 0x000000000047a861 in BackendRun (port=0x1330430) at postmaster.c:4361#14 BackendStartup (port=0x1330430) at postmaster.c:4033#15 ServerLoop () at postmaster.c:1706#16 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x13093c0) at postmaster.c:1379#17 0x000000000047b2a1 in main (argc=3, argv=0x13093c0) at main.c:228(gdb) finishRun till exit from #0 postgresGetForeignRelSize (root=0x13342e8, baserel=0x13349e8, foreigntableid=16392) at postgres_fdw.c:535set_foreign_size (rte=0x130f778, rel=0x13349e8, root=0x13342e8) at allpaths.c:842842 rel-&gt;rows = clamp_row_est(rel-&gt;rows);(gdb) finishRun till exit from #0 set_foreign_size (rte=0x130f778, rel=0x13349e8, root=0x13342e8) at allpaths.c:842415 &#125;(gdb) finishRun till exit from #0 set_rel_size (root=root@entry=0x13342e8, rel=rel@entry=0x13349e8, rti=rti@entry=1, rte=&lt;optimized out&gt;) at allpaths.c:415set_base_rel_sizes (root=&lt;optimized out&gt;) at allpaths.c:253253 for (rti = 1; rti &lt; root-&gt;simple_rel_array_size; rti++)(gdb) finishRun till exit from #0 set_base_rel_sizes (root=&lt;optimized out&gt;) at allpaths.c:253180 set_base_rel_pathlists(root);(gdb) finishRun till exit from #0 make_one_rel (root=root@entry=0x13342e8, joinlist=joinlist@entry=0x1334e50) at allpaths.c:180Breakpoint 2, postgresGetForeignPaths (root=0x13342e8, baserel=0x13349e8, foreigntableid=16392) at postgres_fdw.c:921921 &#123;(gdb) bt#0 postgresGetForeignPaths (root=0x13342e8, baserel=0x13349e8, foreigntableid=16392) at postgres_fdw.c:921#1 0x0000000000660452 in set_foreign_pathlist (rte=0x130f778, rel=0x13349e8, root=0x13342e8) at allpaths.c:853#2 set_rel_pathlist (root=root@entry=0x13342e8, rel=0x13349e8, rti=rti@entry=1, rte=0x130f778) at allpaths.c:442#3 0x0000000000660a30 in set_base_rel_pathlists (root=&lt;optimized out&gt;) at allpaths.c:310#4 make_one_rel (root=root@entry=0x13342e8, joinlist=joinlist@entry=0x1334e50) at allpaths.c:180#5 0x000000000067de9e in query_planner (root=root@entry=0x13342e8, tlist=tlist@entry=0x1334788, qp_callback=qp_callback@entry=0x67f290 &lt;standard_qp_callback&gt;, qp_extra=qp_extra@entry=0x7fff8c772f00) at planmain.c:259#6 0x0000000000681f43 in grouping_planner (root=root@entry=0x13342e8, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:1897#7 0x0000000000684218 in subquery_planner (glob=glob@entry=0x130fc38, parse=parse@entry=0x130f668, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:966#8 0x0000000000685236 in standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:405#9 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0x130f668, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809#10 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875#11 0x0000000000721cda in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1050#12 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#13 0x000000000047a861 in BackendRun (port=0x1330430) at postmaster.c:4361#14 BackendStartup (port=0x1330430) at postmaster.c:4033#15 ServerLoop () at postmaster.c:1706#16 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x13093c0) at postmaster.c:1379#17 0x000000000047b2a1 in main (argc=3, argv=0x13093c0) at main.c:228(gdb) finishRun till exit from #0 postgresGetForeignPaths (root=0x13342e8, baserel=0x13349e8, foreigntableid=16392) at postgres_fdw.c:9210x0000000000660452 in set_foreign_pathlist (rte=0x130f778, rel=0x13349e8, root=0x13342e8) at allpaths.c:853853 rel-&gt;fdwroutine-&gt;GetForeignPaths(root, rel, rte-&gt;relid);(gdb) finishRun till exit from #0 0x0000000000660452 in set_foreign_pathlist (rte=0x130f778, rel=0x13349e8, root=0x13342e8) at allpaths.c:853495 if (rel-&gt;reloptkind == RELOPT_BASEREL &amp;&amp;(gdb) finishRun till exit from #0 set_rel_pathlist (root=root@entry=0x13342e8, rel=0x13349e8, rti=rti@entry=1, rte=0x130f778) at allpaths.c:4950x0000000000660a30 in set_base_rel_pathlists (root=&lt;optimized out&gt;) at allpaths.c:310310 set_rel_pathlist(root, rel, rti, root-&gt;simple_rte_array[rti]);(gdb) finishRun till exit from #0 0x0000000000660a30 in set_base_rel_pathlists (root=&lt;optimized out&gt;) at allpaths.c:310185 rel = make_rel_from_joinlist(root, joinlist);(gdb) finishRun till exit from #0 make_one_rel (root=root@entry=0x13342e8, joinlist=joinlist@entry=0x1334e50) at allpaths.c:185query_planner (root=root@entry=0x13342e8, tlist=tlist@entry=0x1334788, qp_callback=qp_callback@entry=0x67f290 &lt;standard_qp_callback&gt;, qp_extra=qp_extra@entry=0x7fff8c772f00) at planmain.c:262262 if (!final_rel || !final_rel-&gt;cheapest_total_path ||Value returned is $3 = (RelOptInfo *) 0x13349e8(gdb) finishRun till exit from #0 query_planner (root=root@entry=0x13342e8, tlist=tlist@entry=0x1334788, qp_callback=qp_callback@entry=0x67f290 &lt;standard_qp_callback&gt;, qp_extra=qp_extra@entry=0x7fff8c772f00) at planmain.c:262grouping_planner (root=root@entry=0x13342e8, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:19071907 final_target = create_pathtarget(root, tlist);Value returned is $4 = (RelOptInfo *) 0x13349e8(gdb) finishRun till exit from #0 grouping_planner (root=root@entry=0x13342e8, inheritance_update=inheritance_update@entry=false, tuple_fraction=&lt;optimized out&gt;, tuple_fraction@entry=0) at planner.c:1907subquery_planner (glob=glob@entry=0x130fc38, parse=parse@entry=0x130f668, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:972972 SS_identify_outer_params(root);(gdb) finishRun till exit from #0 subquery_planner (glob=glob@entry=0x130fc38, parse=parse@entry=0x130f668, parent_root=parent_root@entry=0x0, hasRecursion=hasRecursion@entry=false, tuple_fraction=tuple_fraction@entry=0) at planner.c:972standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:409409 final_rel = fetch_upper_rel(root, UPPERREL_FINAL, NULL);Value returned is $5 = (PlannerInfo *) 0x13342e8(gdb) finishRun till exit from #0 standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:409Breakpoint 3, postgresGetForeignPlan (root=0x13342e8, foreignrel=0x13349e8, foreigntableid=16392, best_path=0x1334dc0, tlist=0x13cbdd8, scan_clauses=0x0, outer_plan=0x0) at postgres_fdw.c:11311131 &#123;(gdb) bt#0 postgresGetForeignPlan (root=0x13342e8, foreignrel=0x13349e8, foreigntableid=16392, best_path=0x1334dc0, tlist=0x13cbdd8, scan_clauses=0x0, outer_plan=0x0) at postgres_fdw.c:1131#1 0x000000000067a0c1 in create_foreignscan_plan (scan_clauses=&lt;optimized out&gt;, tlist=0x13cbdd8, best_path=0x1334dc0, root=0x13342e8) at createplan.c:3597#2 create_scan_plan (root=root@entry=0x13342e8, best_path=best_path@entry=0x1334dc0, flags=&lt;optimized out&gt;, flags@entry=1) at createplan.c:714#3 0x0000000000677557 in create_plan_recurse (root=root@entry=0x13342e8, best_path=0x1334dc0, flags=flags@entry=1) at createplan.c:390#4 0x0000000000679dc9 in create_plan (root=root@entry=0x13342e8, best_path=&lt;optimized out&gt;) at createplan.c:327#5 0x0000000000685264 in standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:412#6 0x000000000072178c in pg_plan_query (querytree=querytree@entry=0x130f668, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:809#7 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875#8 0x0000000000721cda in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1050#9 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#10 0x000000000047a861 in BackendRun (port=0x1330430) at postmaster.c:4361#11 BackendStartup (port=0x1330430) at postmaster.c:4033#12 ServerLoop () at postmaster.c:1706#13 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x13093c0) at postmaster.c:1379#14 0x000000000047b2a1 in main (argc=3, argv=0x13093c0) at main.c:228(gdb) finishRun till exit from #0 postgresGetForeignPlan (root=0x13342e8, foreignrel=0x13349e8, foreigntableid=16392, best_path=0x1334dc0, tlist=0x13cbdd8, scan_clauses=0x0, outer_plan=0x0) at postgres_fdw.c:1131create_foreignscan_plan (scan_clauses=&lt;optimized out&gt;, tlist=0x13cbdd8, best_path=0x1334dc0, root=0x13342e8) at createplan.c:36033603 copy_generic_path_info(&amp;scan_plan-&gt;scan.plan, &amp;best_path-&gt;path);Value returned is $6 = (ForeignScan *) 0x13105b0(gdb) finishRun till exit from #0 create_foreignscan_plan (scan_clauses=&lt;optimized out&gt;, tlist=0x13cbdd8, best_path=0x1334dc0, root=0x13342e8) at createplan.c:3603718 break;(gdb) finishRun till exit from #0 create_scan_plan (root=root@entry=0x13342e8, best_path=best_path@entry=0x1334dc0, flags=&lt;optimized out&gt;, flags@entry=1) at createplan.c:7180x0000000000677557 in create_plan_recurse (root=root@entry=0x13342e8, best_path=0x1334dc0, flags=flags@entry=1) at createplan.c:390390 plan = create_scan_plan(root, best_path, flags);Value returned is $7 = (Plan *) 0x13105b0(gdb) finishRun till exit from #0 0x0000000000677557 in create_plan_recurse (root=root@entry=0x13342e8, best_path=0x1334dc0, flags=flags@entry=1) at createplan.c:390create_plan (root=root@entry=0x13342e8, best_path=&lt;optimized out&gt;) at createplan.c:336336 if (!IsA(plan, ModifyTable))Value returned is $8 = (Plan *) 0x13105b0(gdb) finishRun till exit from #0 create_plan (root=root@entry=0x13342e8, best_path=&lt;optimized out&gt;) at createplan.c:336standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:418418 if (cursorOptions &amp; CURSOR_OPT_SCROLL)Value returned is $9 = (Plan *) 0x13105b0(gdb) finishRun till exit from #0 standard_planner (parse=0x130f668, cursorOptions=256, boundParams=0x0) at planner.c:418pg_plan_query (querytree=querytree@entry=0x130f668, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:811811 if (log_planner_stats)Value returned is $10 = (PlannedStmt *) 0x130f8d8(gdb) finishRun till exit from #0 pg_plan_query (querytree=querytree@entry=0x130f668, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:8110x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:875875 stmt = pg_plan_query(query, cursorOptions, boundParams);Value returned is $11 = (PlannedStmt *) 0x130f8d8(gdb) finishRun till exit from #0 0x000000000072186e in pg_plan_queries (querytrees=&lt;optimized out&gt;, cursorOptions=cursorOptions@entry=256, boundParams=boundParams@entry=0x0) at postgres.c:8750x0000000000721cda in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:10501050 plantree_list = pg_plan_queries(querytree_list,Value returned is $12 = (List *) 0x13cc7d8(gdb) finishRun till exit from #0 0x0000000000721cda in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1050Breakpoint 4, postgresBeginForeignScan (node=0x13bf120, eflags=16) at postgres_fdw.c:13141314 &#123;(gdb) bt#0 postgresBeginForeignScan (node=0x13bf120, eflags=16) at postgres_fdw.c:1314#1 0x00000000006190fc in ExecInitForeignScan (node=node@entry=0x13105b0, estate=estate@entry=0x13bef10, eflags=eflags@entry=16) at nodeForeignscan.c:229#2 0x00000000005f6694 in ExecInitNode (node=node@entry=0x13105b0, estate=estate@entry=0x13bef10, eflags=eflags@entry=16) at execProcnode.c:277#3 0x00000000005f11c5 in InitPlan (eflags=16, queryDesc=&lt;optimized out&gt;) at execMain.c:1049#4 standard_ExecutorStart (queryDesc=&lt;optimized out&gt;, eflags=16) at execMain.c:264#5 0x00000000007255e2 in PortalStart (portal=portal@entry=0x1373f50, params=params@entry=0x0, eflags=eflags@entry=0, snapshot=snapshot@entry=0x0) at pquery.c:520#6 0x0000000000721b42 in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1083#7 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#8 0x000000000047a861 in BackendRun (port=0x1330430) at postmaster.c:4361#9 BackendStartup (port=0x1330430) at postmaster.c:4033#10 ServerLoop () at postmaster.c:1706#11 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x13093c0) at postmaster.c:1379#12 0x000000000047b2a1 in main (argc=3, argv=0x13093c0) at main.c:228(gdb) finishRun till exit from #0 postgresBeginForeignScan (node=0x13bf120, eflags=16) at postgres_fdw.c:13140x00000000006190fc in ExecInitForeignScan (node=node@entry=0x13105b0, estate=estate@entry=0x13bef10, eflags=eflags@entry=16) at nodeForeignscan.c:229229 fdwroutine-&gt;BeginForeignScan(scanstate, eflags);(gdb) finishRun till exit from #0 0x00000000006190fc in ExecInitForeignScan (node=node@entry=0x13105b0, estate=estate@entry=0x13bef10, eflags=eflags@entry=16) at nodeForeignscan.c:2290x00000000005f6694 in ExecInitNode (node=node@entry=0x13105b0, estate=estate@entry=0x13bef10, eflags=eflags@entry=16) at execProcnode.c:277277 result = (PlanState *) ExecInitForeignScan((ForeignScan *) node,Value returned is $13 = (ForeignScanState *) 0x13bf120(gdb) finishRun till exit from #0 0x00000000005f6694 in ExecInitNode (node=node@entry=0x13105b0, estate=estate@entry=0x13bef10, eflags=eflags@entry=16) at execProcnode.c:277InitPlan (eflags=16, queryDesc=&lt;optimized out&gt;) at execMain.c:10541054 tupType = ExecGetResultType(planstate);Value returned is $14 = (PlanState *) 0x13bf120(gdb) finishRun till exit from #0 InitPlan (eflags=16, queryDesc=&lt;optimized out&gt;) at execMain.c:1054266 MemoryContextSwitchTo(oldcontext);(gdb) finishRun till exit from #0 standard_ExecutorStart (queryDesc=&lt;optimized out&gt;, eflags=16) at execMain.c:266PortalStart (portal=portal@entry=0x1373f50, params=params@entry=0x0, eflags=eflags@entry=0, snapshot=snapshot@entry=0x0) at pquery.c:525525 portal-&gt;queryDesc = queryDesc;(gdb) finishRun till exit from #0 PortalStart (portal=portal@entry=0x1373f50, params=params@entry=0x0, eflags=eflags@entry=0, snapshot=snapshot@entry=0x0) at pquery.c:525exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:10921092 if (IsA(parsetree-&gt;stmt, FetchStmt))(gdb) finishRun till exit from #0 exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1092Breakpoint 5, postgresIterateForeignScan (node=0x13bf120) at postgres_fdw.c:14181418 &#123;(gdb) bt#0 postgresIterateForeignScan (node=0x13bf120) at postgres_fdw.c:1418#1 0x0000000000618f6b in ForeignNext (node=node@entry=0x13bf120) at nodeForeignscan.c:54#2 0x00000000005f7b2a in ExecScanFetch (recheckMtd=0x618e40 &lt;ForeignRecheck&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, node=0x13bf120) at execScan.c:95#3 ExecScan (node=0x13bf120, accessMtd=0x618ed0 &lt;ForeignNext&gt;, recheckMtd=0x618e40 &lt;ForeignRecheck&gt;) at execScan.c:145#4 0x00000000005f000a in ExecProcNode (node=0x13bf120) at ../../../src/include/executor/executor.h:237#5 ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x1335d78, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=true, operation=CMD_SELECT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x13bf120, estate=0x13bef10) at execMain.c:1726#6 standard_ExecutorRun (queryDesc=0x1330130, direction=&lt;optimized out&gt;, count=0, execute_once=&lt;optimized out&gt;) at execMain.c:363#7 0x00000000007247fb in PortalRunSelect (portal=portal@entry=0x1373f50, forward=forward@entry=true, count=0, count@entry=9223372036854775807, dest=dest@entry=0x1335d78) at pquery.c:932#8 0x0000000000725b10 in PortalRun (portal=portal@entry=0x1373f50, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x1335d78, altdest=altdest@entry=0x1335d78, completionTag=completionTag@entry=0x7fff8c773240 \"\") at pquery.c:773#9 0x0000000000721bb7 in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1122#10 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#11 0x000000000047a861 in BackendRun (port=0x1330430) at postmaster.c:4361#12 BackendStartup (port=0x1330430) at postmaster.c:4033#13 ServerLoop () at postmaster.c:1706#14 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x13093c0) at postmaster.c:1379#15 0x000000000047b2a1 in main (argc=3, argv=0x13093c0) at main.c:228(gdb) finishRun till exit from #0 postgresIterateForeignScan (node=0x13bf120) at postgres_fdw.c:14180x0000000000618f6b in ForeignNext (node=node@entry=0x13bf120) at nodeForeignscan.c:5454 slot = node-&gt;fdwroutine-&gt;IterateForeignScan(node);Value returned is $15 = (TupleTableSlot *) 0x13bf730(gdb) finishRun till exit from #0 0x0000000000618f6b in ForeignNext (node=node@entry=0x13bf120) at nodeForeignscan.c:540x00000000005f7b2a in ExecScanFetch (recheckMtd=0x618e40 &lt;ForeignRecheck&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, node=0x13bf120) at execScan.c:9595 return (*accessMtd) (node);Value returned is $16 = (TupleTableSlot *) 0x13bf730(gdb) finishRun till exit from #0 0x00000000005f7b2a in ExecScanFetch (recheckMtd=0x618e40 &lt;ForeignRecheck&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, node=0x13bf120) at execScan.c:95219 &#125;(gdb) finishRun till exit from #0 ExecScan (node=&lt;optimized out&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, recheckMtd=0x618e40 &lt;ForeignRecheck&gt;) at execScan.c:219ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x1335d78, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=true, operation=CMD_SELECT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x13bf120, estate=0x13bef10) at execMain.c:17321732 if (TupIsNull(slot))Value returned is $17 = (TupleTableSlot *) 0x13bf730(gdb) finishRun till exit from #0 ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x1335d78, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=true, operation=CMD_SELECT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x13bf120, estate=0x13bef10) at execMain.c:1732363 ExecutePlan(estate,(gdb) finishRun till exit from #0 standard_ExecutorRun (queryDesc=0x1330130, direction=&lt;optimized out&gt;, count=0, execute_once=&lt;optimized out&gt;) at execMain.c:363Breakpoint 5, postgresIterateForeignScan (node=0x13bf120) at postgres_fdw.c:14181418 &#123;# 再次进入postgresIterateForeignScan.后续跳过中间的8次，...Breakpoint 5, postgresIterateForeignScan (node=0x13bf120) at postgres_fdw.c:14181418 &#123;(gdb) finishRun till exit from #0 postgresIterateForeignScan (node=0x13bf120) at postgres_fdw.c:14180x0000000000618f6b in ForeignNext (node=node@entry=0x13bf120) at nodeForeignscan.c:5454 slot = node-&gt;fdwroutine-&gt;IterateForeignScan(node);Value returned is $45 = (TupleTableSlot *) 0x13bf730(gdb) finishRun till exit from #0 0x0000000000618f6b in ForeignNext (node=node@entry=0x13bf120) at nodeForeignscan.c:540x00000000005f7b2a in ExecScanFetch (recheckMtd=0x618e40 &lt;ForeignRecheck&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, node=0x13bf120) at execScan.c:9595 return (*accessMtd) (node);Value returned is $46 = (TupleTableSlot *) 0x13bf730(gdb) finishRun till exit from #0 0x00000000005f7b2a in ExecScanFetch (recheckMtd=0x618e40 &lt;ForeignRecheck&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, node=0x13bf120) at execScan.c:95219 &#125;(gdb) finishRun till exit from #0 ExecScan (node=&lt;optimized out&gt;, accessMtd=0x618ed0 &lt;ForeignNext&gt;, recheckMtd=0x618e40 &lt;ForeignRecheck&gt;) at execScan.c:219ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x1335d78, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=true, operation=CMD_SELECT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x13bf120, estate=0x13bef10) at execMain.c:17321732 if (TupIsNull(slot))Value returned is $47 = (TupleTableSlot *) 0x13bf730(gdb) finishRun till exit from #0 ExecutePlan (execute_once=&lt;optimized out&gt;, dest=0x1335d78, direction=&lt;optimized out&gt;, numberTuples=0, sendTuples=true, operation=CMD_SELECT, use_parallel_mode=&lt;optimized out&gt;, planstate=0x13bf120, estate=0x13bef10) at execMain.c:1732377 if (sendTuples)(gdb) finishRun till exit from #0 standard_ExecutorRun (queryDesc=0x1330130, direction=&lt;optimized out&gt;, count=0, execute_once=&lt;optimized out&gt;) at execMain.c:377PortalRunSelect (portal=portal@entry=0x1373f50, forward=forward@entry=true, count=0, count@entry=9223372036854775807, dest=dest@entry=0x1335d78) at pquery.c:934934 nprocessed = queryDesc-&gt;estate-&gt;es_processed;(gdb) finishRun till exit from #0 PortalRunSelect (portal=portal@entry=0x1373f50, forward=forward@entry=true, count=0, count@entry=9223372036854775807, dest=dest@entry=0x1335d78) at pquery.c:934PortalRun (portal=portal@entry=0x1373f50, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x1335d78, altdest=altdest@entry=0x1335d78, completionTag=completionTag@entry=0x7fff8c773240 \"\") at pquery.c:780780 if (completionTag &amp;&amp; portal-&gt;commandTag)Value returned is $48 = 10(gdb) finishRun till exit from #0 PortalRun (portal=portal@entry=0x1373f50, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x1335d78, altdest=altdest@entry=0x1335d78, completionTag=completionTag@entry=0x7fff8c773240 \"\") at pquery.c:780exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:11301130 receiver-&gt;rDestroy(receiver);Value returned is $49 = true(gdb) finishRun till exit from #0 exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1130Breakpoint 7, postgresEndForeignScan (node=0x13bf120) at postgres_fdw.c:15151515 &#123;(gdb) bt#0 postgresEndForeignScan (node=0x13bf120) at postgres_fdw.c:1515#1 0x0000000000619173 in ExecEndForeignScan (node=0x13bf120) at nodeForeignscan.c:249#2 0x00000000005f16ad in ExecEndPlan (estate=0x13bef10, planstate=&lt;optimized out&gt;) at execMain.c:1612#3 standard_ExecutorEnd (queryDesc=0x1330130) at execMain.c:495#4 0x00000000005abfc4 in PortalCleanup (portal=&lt;optimized out&gt;) at portalcmds.c:301#5 0x000000000084445a in PortalDrop (portal=0x1373f50, isTopCommit=&lt;optimized out&gt;) at portalmem.c:499#6 0x0000000000721bc8 in exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:1132#7 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153#8 0x000000000047a861 in BackendRun (port=0x1330430) at postmaster.c:4361#9 BackendStartup (port=0x1330430) at postmaster.c:4033#10 ServerLoop () at postmaster.c:1706#11 0x00000000006babb9 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x13093c0) at postmaster.c:1379#12 0x000000000047b2a1 in main (argc=3, argv=0x13093c0) at main.c:228(gdb) finishRun till exit from #0 postgresEndForeignScan (node=0x13bf120) at postgres_fdw.c:15150x0000000000619173 in ExecEndForeignScan (node=0x13bf120) at nodeForeignscan.c:249249 node-&gt;fdwroutine-&gt;EndForeignScan(node);(gdb) finishRun till exit from #0 0x0000000000619173 in ExecEndForeignScan (node=0x13bf120) at nodeForeignscan.c:249ExecEndPlan (estate=0x13bef10, planstate=&lt;optimized out&gt;) at execMain.c:16171617 foreach(l, estate-&gt;es_subplanstates)(gdb) finishRun till exit from #0 ExecEndPlan (estate=0x13bef10, planstate=&lt;optimized out&gt;) at execMain.c:1617498 UnregisterSnapshot(estate-&gt;es_snapshot);(gdb) finishRun till exit from #0 standard_ExecutorEnd (queryDesc=0x1330130) at execMain.c:498PortalCleanup (portal=&lt;optimized out&gt;) at portalcmds.c:302302 FreeQueryDesc(queryDesc);(gdb) finishRun till exit from #0 PortalCleanup (portal=&lt;optimized out&gt;) at portalcmds.c:302PortalDrop (portal=0x1373f50, isTopCommit=&lt;optimized out&gt;) at portalmem.c:500500 portal-&gt;cleanup = NULL;(gdb) finishRun till exit from #0 PortalDrop (portal=0x1373f50, isTopCommit=&lt;optimized out&gt;) at portalmem.c:500exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:11341134 if (lnext(parsetree_item) == NULL)(gdb) finishRun till exit from #0 exec_simple_query (query_string=0x130e810 \"select * from t_fdw;\") at postgres.c:11340x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:41534153 exec_simple_query(query_string);(gdb) finishRun till exit from #0 0x0000000000722e62 in PostgresMain (argc=&lt;optimized out&gt;, argv=argv@entry=0x1338568, dbname=0x1338450 \"fdw\", username=&lt;optimized out&gt;) at postgres.c:4153# 说明，postgresIterateForeignScan一共调用了11次，因为外部表总行数是10行，postgresIterateForeignScan最后一次调用返回NULL，用于结束迭代。fdw=# insert into t_test values(2,'1');INSERT 0 1fdw=# select * from t_fdw; id | c1 | c2 ----+------------+---- 1 | 1 | 2 2 | 1 | 2 3 | 1 | 2 4 | 1 | 2 5 | 1 | 2 6 | 1 | 2 7 | 1 | 2 8 | 1 | 2 9 | 1 | 2 10 | 1 | 2(10 rows) 根据以上的代码跟踪，可以更好的理解实现FDW的7个必须回调函数的调用时机，如果对PostgreSQL的查询机制更加熟悉的话，或许对于如何实现这个7个回调函数跟有帮助。","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"},{"name":"gdb","slug":"gdb","permalink":"https://oyo-byte.github.io/tags/gdb/"}]},{"title":"学习PostgreSQL的查询机制","slug":"learn_about_pg_query_processing","date":"2018-08-03T10:10:45.600Z","updated":"2018-08-17T08:26:32.716Z","comments":true,"path":"2018/08/03/learn_about_pg_query_processing/","link":"","permalink":"https://oyo-byte.github.io/2018/08/03/learn_about_pg_query_processing/","excerpt":"","text":"概述在PostgreSQL中，查询语句经过以下5个子系统处理： Parser用于将文本式的SQL命令转换成解析树 Analyzer/Analyser用于执行解析树的语义分析并生成查询树 Rewriter重写器用于根据规则系统中已存在的规则转换查询树 Planner规划器生成可以从查询树中最有效地执行的计划树 Executor执行器通过按计划树创建的顺序访问表和索引来执行查询 Parser未完待续","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"}]},{"title":"学习PostgreSQL的FDW(#1)","slug":"learn_about_pgfdw","date":"2018-08-03T07:52:42.563Z","updated":"2018-08-07T17:14:45.415Z","comments":true,"path":"2018/08/03/learn_about_pgfdw/","link":"","permalink":"https://oyo-byte.github.io/2018/08/03/learn_about_pgfdw/","excerpt":"","text":"实现一个FDW的核心是实现一组回调函数，有了这些回调函数的帮助, 在查询外部表对象的执行过程中就可以将运行逻辑切换至自定义的扩展代码中, 进而遵照PG的内部机制实现对外部数据源的访问。 目前PostgreSQL11 beta2，提供的FDW回调函数接口有39个。FDW的实现者需要根据外部数据源自身的能力（比如是否支持写操作，以及是否支持在外部数据源端执行join操作等等）对这些接口有选择地予以实现。 这些接口中, 最核心的接口有7个。无论外部数据源自身能力如何, 这7个接口是实现通过外部表对象访问该数据源的必须接口。它们的接口定义如下: 12345678910111213typedef void (*GetForeignRelSize_function) (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);typedef void (*GetForeignPaths_function) (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);typedef ForeignScan *(*GetForeignPlan_function) (PlannerInfo *root, RelOptInfo *baserel,Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan);typedef void (*BeginForeignScan_function) (ForeignScanState *node, int eflags);typedef TupleTableSlot *(*IterateForeignScan_function) (ForeignScanState *node);typedef void (*ReScanForeignScan_function) (ForeignScanState *node);typedef void (*EndForeignScan_function) (ForeignScanState *node); 在PG中，查询语句经过以下5个子系统处理： Parser用于将文本式的SQL命令转换成解析树 Analyzer/Analyser用于执行解析树的语义分析并生成查询树 Rewriter重写器用于根据规则系统中已存在的规则转换查询树 Planner规划器生成可以从查询树中最有效地执行的计划树 Executor执行器通过按计划树创建的顺序访问表和索引来执行查询 可以整合成三个大阶段： Parser: 包含对SQL的语法解析，语义校验，查询重写 Optimizer：生成查询计划 Executor：按照火山模型执行查询计划的算子并向上返回数据 PG的FDW所需的7个回调函数主要是在Optimizer和Executor阶段进行“介入”: 这7个回调函数详细的调用时机以及作用： 回调函数 在PG中的调用时机 作用 详细描述 GetForeignRelSize 优化器生成访问路径的过程中对外部表估算访问代价时 提供外部表对于计算访问代价所需的基础数据，如表的元组数以及元组的平均长度,并将这些数据保存在输入参数baserel的字段”rows”以及”width”中 void GetForeignRelSize (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid); root是规划器的关于该查询的全局信息；baserel是规划器的关于该表的信息；foreigntableid是外部表在pg_class中的 OID （foreigntableid可以从规划器的数据结构中获得，但是为了减少工作量，这里直接显式地将它传递给函数）；这个函数应该更新baserel-&gt;rows为表扫描根据限制条件完成了过滤后将返回的预期行数。baserel-&gt;rows的初始值只是一个常数的默认估计值，应该尽可能把它替换掉。如果该函数能够计算出一个平均结果行宽度的更好的估计值，该函数也可能选择更新baserel-&gt;width。 GetForeignPaths 生成对外部表的访问路径时 生成对目标外部表的访问路径(通过PG中的接口createforeignscanpath()生成) void GetForeignPaths (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);参数和GetForeignRelSize相同；这个函数必须为外部表上的扫描生成至少一个访问路径（ForeignPath节点），并且必须调用add_path把每一个这样的路径加入到baserel-&gt;pathlist中。我们推荐使用create_foreignscan_path来建立ForeignPath节点。该函数可以生成多个访问路径，例如一个具有合法pathkeys的路径表示一个预排序好的结果。每一个访问路径必须包含代价估计，并且能包含任何FDW的私有信息，这种信息被用来标识想要使用的指定扫描方法。 GetForeignPlan 优化器生成扫描外部表的查询计划节点时 生成访问目标外部表的ForeignScan计划节点(通过PG中的接口make_foreignscan()) ForeignScan * GetForeignPlan (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan);参数和GetForeignRelSize的一样，外加选中的ForeignPath（在前面由GetForeignPaths、GetForeignJoinPaths或者GetForeignUpperPaths产生）、被计划节点发出的目标列表以及计划节点强制的限制子句以及被RecheckForeignScan执行的复查所使用的ForeignScan的外子计划（如果该路径是用于一个连接而非基本关系，则foreigntableid是InvalidOid）；这个函数必须创建并返回一个ForeignScan计划节点，推荐使用make_foreignscan来建立ForeignScan节点。 BeginForeignScan 执行器即将开始执行ForeignScan算子，进行该算子相关的初始化时 获取执行ForeignScan算子所需的信息，并将它们组织并保存在ForeignScanState中 void BeginForeignScan (ForeignScanState *node, int eflags);它应该执行任何在扫描能够开始之前需要完成的初始化工作，但是并不开始执行真正的扫描（会在第一次调用IterateForeignScan时完成）。ForeignScanState节点已经被创建好了，但是它的fdw_state属性仍然为 NULL。关于要被扫描的表的信息可以通过ForeignScanState节点访问（特殊地，从底层的ForeignScan计划节点，它包含任何由GetForeignPlan提供的FDW私有信息）。eflags包含描述执行器对该计划节点操作模式的标志位。注意当(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)为真时，这个函数不应该执行任何外部可见的动作；它应当只做最少的事情来创建对ExplainForeignScan 和EndForeignScan有效的节点状态 IterateForeignScan 执行ForeignScan算子过程中需要获取下一元组时 读取外部数据源的一行数据，并将它组织为PG中的Tuple(即TupleTableSlot). 当该回调函数返回一个空的TupleTableSlot结构时, 迭代器停止迭代 TupleTableSlot * IterateForeignScan (ForeignScanState *node);从外部源获得一行，将它放在一个元组表槽中返回（节点的ScanTupleSlot应当被用于此目的）。如果没有更多的行可用则返回 NULL。元组表槽设施允许一个物理的或者虚拟的元组被返回；在大部分情况下出于性能的考虑会倾向于选择后者。注意这是在一个短期存在的内存上下文中被调用的，该内存上下文会在调用之间被重置。如果需要长期存在的存储，需要在BeginForeignScan中创建内存上下文，或者使用节点的EState中的es_query_cxt。如果提供了fdw_scan_tlist目标列表，被返回的行必须匹配它，如果没有提供则它们必须匹配被扫描的外部表的行类型。如果选择优化掉不需要的列，你应该在那些列的位置上插入控制或者生成一个忽略了那些列的fdw_scan_tlist列表。注意PostgreSQL的执行器并不在乎被返回的行是否违背了定义在该外部表上的任何约束 — 但是规划器会在乎这一点，并且如果在外部表中有可见行不满足一个约束，规划器可能会错误地优化查询。如果当用户已经声明一个约束应该为真时它却被违背，最合适的处理可能是产生一个错误（就像在数据类型失配的情况下所作的那样） ReScanForeignScan 执行Nested Loop过程中需要重置Inner Scan时(即Outter Scan需要向前推进一行时) 将外部数据源的读取位置重置回最初的起始位置 void ReScanForeignScan (ForeignScanState *node);注意扫描所依赖的任何参数可能已经改变了值，因此新扫描不一定会返回完全相同的行。 EndForeignScan ForeignScan算子执行完成时 释放整个ForeignScan算子执行过程中占用的外部资源或FDW中的资源 void EndForeignScan (ForeignScanState *node);通常释放palloc过的内存并不重要，但是打开的文件和到远程服务器的连接等应该被清理。 以上是必须实现的扫描相关的回调函数 参考： http://www.interdb.jp/pg/pgsql03.htmlhttps://xiaowing.github.io/post/20180513_write_pgfdw_in_golang_part02/","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"}]},{"title":"解读C语言声明","slug":"解读C语言声明","date":"2018-07-26T03:18:23.922Z","updated":"2018-08-07T15:50:27.959Z","comments":true,"path":"2018/07/26/解读C语言声明/","link":"","permalink":"https://oyo-byte.github.io/2018/07/26/解读C语言声明/","excerpt":"","text":"C语言所有复杂的指针声明，都是由各种声明嵌套构成的。如何解读复杂指针声明呢？ 右左法则（既著名又常用的方法 ） 右左法则英文原文： The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed. 翻译如下： 右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。 这时就会有个疑惑：怎样判断那个括号是最里面的呢？ 因此需要对这个法则进行修改，结合《C专家编程》里提到的分析方法，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。 分析C语言的声明步骤： 第1步：从左至右，找到第一个未定义的标识符。 第2步：查看标识符右边的符号，并确定是一个数组还是函数。 第3步：查看左边的符号。 第3步a：如果是左括号则将处理过的部分结合到一起直到遇到右括号作为标识符返回第2步。 第3步b：如果是const，volatile，*其中之一则继续向左直到不是这三个符号之一。 第4步：剩下的符号构成声明的基本类型。 感觉还是有点晕？ 结合例子说明： 1char (*(*x[3])())[5]; 第1步：从左到右找到第一个标识符x。 第2步：查看标识符右边的符号是[，说明x是一个具有3个元素的数组。 第3步：查看左边的符号是*，转至第3步b。 第3步b：说明数组中的元素都是指针，向左就是左括号了，将这个左括号结合到对应的右括号（也就是(*x[3])）作为新的标识符返回第2步 。 第2步：查看右边的符号是(，说明指针是指向参数列表为空的函数的指针。 查看左边的符号，是*, 转至第3步b。 说明函数的返回值是指针，向左是左括号，将这个左括号结合到对应的右括号（也就是(*(*x[3])())）作为新的标识符返回第2步。 第2步：查看右边的符号是[，所以是指向具有五个元素的数组的指针。 第3步：查看左边的括号，既不是a情况，也不是b情况，跳至第4步。 第4步：数组的类型为char。 所以以上的声明表示的是x是一个具有3个元素的数组，数组的每个元素都是一个指向函数的指针，函数的参数列表为空，返回值是指向一个具有5个元素的指针，元素的类型为char。 来个程序验证一下12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;char *func()&#123; char arr[5] = &#123;'1', '2', '3','4','5'&#125;; return arr;&#125;int main()&#123; char (*(*x[3])())[5]; // x是一个长度为3的数组，元素是一个函数指针，函数的返回值是指向一个长度为5的char型数组指针。 x[0] = &amp;func; printf(\"x的总长度：%d \\n\",sizeof(x)); printf(\"x元素的长度：%d \\n\",sizeof(x[0])); printf(\"函数指针的长度：%d \\n\",sizeof(void *)); printf(\"x的元素个数：%d \\n\",sizeof(x)/sizeof(x[0])); char (*c)[5] = (x[0])();//c是一个指向长度为5的char型数组的指针 printf(\"c的总长度：%d \\n\",sizeof(*c)); printf(\"c元素的长度：%d \\n\",sizeof((*c)[0])); printf(\"char型的长度：%d \\n\",sizeof(char)); printf(\"c的第4个元素是：%c \\n\",(*c)[3]); printf(\"整体调用，第4个元素是：%c \\n\",(*(x[0])())[3]); return 0;&#125; 运行结果：123456789x的总长度：24x元素的长度：8函数指针的长度：8x的元素个数：3c的总长度：5c元素的长度：1chart性的长度：1c的第4个元素是：4整体调用，结果的第4个元素是：4 Try: 11. char *(*c[10])(int **p) Clockwise/Spiral Rule（顺时针/螺旋法则） 三步： 从未定义标识符开始，以顺时针方向移动，当遇到以下元素时，用相应的语言陈述替换它们： ​ [X] or [] =&gt; Array X size of… or Array undefined size of… ​ (type1, type2) =&gt; function passing type1 and type2 returning… ​ * =&gt; pointer(s) to… 继续以上步骤，直至覆盖所有的字符。 首先解决括号中的内容。 例1： 1char *str[10]; 1234567 +-------+ | +-+ | | ^ | |char *str[10]; ^ ^ | | | +---+ | +-----------+ str是什么？ “str是一个…… 从str开始以顺时针方向移动，遇到[，这意味着是一个数组 “str是一个长度为10的数组，元素是…… 继续移动，遇到*,说明是指针 “str是一个长度为10的数组，元素是指向……的指针 继续遇到了;，然后继续移动，遇到char “str是一个长度为10的数组，元素是指向char的指针” 遍历完所有字符，解析完毕 以上的char (*(*x[3])())[5];亦可这样去处理123456789 +----------+ | +-----+ | | |++ | | | |^| | |char (*(*x[3])())[5]; ^ ^ ^ | | | | | +-+ | | | +-------+ | +---------------+ x是什么？“x是一个…… 从x开始以顺时针方向移动，遇到[，这意味着是一个数组“x是一个长度为3的数组，元素是…… 继续移动，遇到*,说明是指针“x是一个长度为3的数组，元素是指向……的指针 继续遇到(,说明是函数“x是一个长度为3的数组，元素是指向函数的指针，函数是…… 继续遇到*，说明是指针“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向……的指针 继续遇到[，说明是数组“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向长度为5的……类型元素的数组的指针 继续遇到char,说明元素是char型“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向长度为5的char类型元素的数组的指针” 遍历完毕 Try: 122. char *(*fp)( int, float *);3. void (*signal(int, void (*fp)(int)))(int); Answer： c是一个具有10个元素的数组，数组的元素都是函数指针，其所指向的函数是接受一个指向整型指针的指针，返回值是指向char的指针。 123456789 +-----------------+ | +------+ +-+| | |++ | |++| | |^| | |^||char *(*c[10])(int **p); ^ ^ ^ | | ^^ || | | +-+ | |+-+| | +--------+ +--+| +--------------------+ fp是一个函数指针，该函数接受一个整型和一个浮点型指针入参，返回值是指向char的指针。 123456789 +--------------------+ | +---+ | | |+-+| | | |^ || |char *(*fp)( int, float *); ^ ^ ^ || | | | +--+| | | +-----+ | +------------------------+ signal是一个函数，该函数值一个接受一个整型和一个函数指针（该函数是入参是整型，返回值为空void），返回值是指向一个入参是整型，返回值是空void的函数指针。 123456789 +-----------------------------+ | +---+ | | +---+ |+-+| | | ^ | |^ || |void (*signal(int, void (*fp)(int)))(int); ^ ^ | ^ ^ || | | +------+ | +--+| | | +--------+ | +----------------------------------+ 参考： C语言复杂声明解析 c语言声明的分析方法 The Clockwise/Spiral Rule","raw":null,"content":null,"categories":[{"name":"C","slug":"C","permalink":"https://oyo-byte.github.io/categories/C/"}],"tags":[]},{"title":"PostgreSQL使用oracle_fdw与Oracle查询性能对比","slug":"PostgreSQL使用oracle_fdw与Oracle查询性能对比","date":"2018-07-25T03:29:52.892Z","updated":"2018-08-07T17:24:14.317Z","comments":true,"path":"2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/","link":"","permalink":"https://oyo-byte.github.io/2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/","excerpt":"","text":"在PostgreSQL中使用oracle_fdw安装oracle_fdw插件 安装前要求： 全部功能要求PostgreSQL9.3及以上 Oracle client要求10.1以上 确保PostgreSQL配置了--without-ldap 确保pg_config在PATH中(用 pg_config --pgxs测试) 设置了ORACLE_HOME环境变量 下载oracle_fdw源代码,并解压到某个目录下，进入文件目录，执行： 12$ make$ make install 安装完毕后，使用psql连接到PostgreSQL；1$ psql -d testdb; 使用PostgreSQL的超级用户配置oralce_fdw: 123testdb=# create extension oracle_fdw;testdb=# create server oracle_121_56 foreign data wrapper oracle_fdw options (dbserver '//192.168.121.56:1521/orcl');testdb=# create user mapping for public server oracle_121_56 options (user 'dbuser' password 'test'); 简单查询，无索引生成测试数据，创建一个表，并同时添加1百万条数据 1create table test_table as select rownum as id,to_char(sysdate + rownum/24/3600, 'yyyy-mm-dd hh24:mi:ss') as inc_datetime,trunc(dbms_random.value(0, 100)) as random_id,dbms_random.string('x', 20) random_string from dual connect by level &lt;= 1000000; 创建完表后，在原来表的基础上追加记录12insert into test_table (ID, INC_DATETIME,RANDOM_ID,RANDOM_STRING) select rownum as id, to_char(sysdate + rownum, 'yyyy-mm-dd hh24:mi:ss') as inc_datetime,trunc(dbms_random.value(0, 100)) as random_id, dbms_random.string('x', 20) random_string from dual connect by level &lt;= 1000000;commit; 上面SQL是利用了Oracle数据库语法的几个实用小技巧实现的: 利用Oracle特有的“connect by”树形连接语法生成测试记录，“level &lt;= 10”表示要生成10记录； 利用rownum虚拟列生成递增的整数数据； 利用sysdate函数加一些简单运算来生成日期数据，本例中是每条记录的时间加1秒； 利用dbms_random.value函数生成随机的数值型数据，本例中是生成0到100之间的随机整数； 利用dbms_random.string函数生成随机的字符型数据，本例中是生成长度为20的随机字符串，字符串中可以包括字符或数字。 to_char(sysdate + rownum, ‘yyyy-mm-dd hh24:mi:ss’) 这里是转换为字符串，如果该字段的类型为TimeStamp时间戳，那这里可以改写一下方法，转换为时间戳 to_timestamp(sysdate + rownum, ‘yyyy-mm-dd hh24:mi:ss’) PostgreSQL 创建相应的外部表 1testdb=# create foreign table test_table(id int, inc_datetime varchar(19), random_id int, random_string varchar(4000)) server oracle_121_56 options (schema 'DBUSER', table 'TEST_TABLE'); 查询表的行数 sqlplus 1$ sqlplus dbuser/test@//192.168.121.56:1521/orcl 12345SQL&gt; select count(*) from test_table; COUNT(*)----------2000000Elapsed: 00:00:00.13 oracle_fdw 123456testdb=# select count(*) from test_table;count---------2000000(1 row)Time: 5264.299 ms (00:05.264) 查看oracle session中真正执行的sql语句，红框为oracle_fdw执行时，oracle session中执行的sql： 在psql中查看select count(*) from test_table;的执行计划： 可见oracle处理的sql即是查询计划中的oracle query后面的sql 查看网络流量oracle_fdw的网络流量明显比sqlplus要高出很多。 查询某条记录 sqlplus 1234567SQL&gt; select * from test_table where id= 50; ID INC_DATETIME RANDOM_ID RANDOM_STRING-------- -------------------- ------------ ----------------------------- 50 2018-07-25 01:13:38 21 2VMPGE0K6Y293T9WRT7G 50 2018-09-13 01:49:31 51 RGUV1BJJNSTNXDMXMVRLElapsed: 00:00:00.05 oracle_fdw 12345678testdb=# select * from test_table where id= 50; id | inc_datetime | random_id | random_string----+---------------------+-----------+---------------------- 50 | 2018-07-25 01:13:38 | 21 | 2VMPGE0K6Y293T9WRT7G 50 | 2018-09-13 01:49:31 | 51 | RGUV1BJJNSTNXDMXMVRL(2 rows)Time: 56.811 ms 使用orderby id获取前5行记录 sqlplus 1234567891011SQL&gt; select * from test_table order by id offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING-------- ------------------- ---------- ---------------------- 1 2018-07-25 01:12:49 17 5SPF1INUG6S2L1ZSTU7R 1 2018-07-26 01:49:31 63 BIO3ZOV104VLNKZWGDZN 2 2018-07-25 01:12:50 95 HJFAWH9L7SF85YSPNDHV 2 2018-07-27 01:49:31 86 2PNXP02ZYWYYUZQFWVVN 3 2018-07-25 01:12:51 86 T3UQBBMP3O02LGO6ONPFElapsed: 00:00:00.32 oracle_fdw 1234567891011testdb=# select * from test_table order by id offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string----+---------------------+-----------+---------------------- 1 | 2018-07-25 01:12:49 | 17 | 5SPF1INUG6S2L1ZSTU7R 1 | 2018-07-26 01:49:31 | 63 | BIO3ZOV104VLNKZWGDZN 2 | 2018-07-27 01:49:31 | 86 | 2PNXP02ZYWYYUZQFWVVN 2 | 2018-07-25 01:12:50 | 95 | HJFAWH9L7SF85YSPNDHV 3 | 2018-07-25 01:12:51 | 86 | T3UQBBMP3O02LGO6ONPF(5 rows)Time: 1169.874 ms (00:01.170) 使用orderby random_string获取前5行记录 sqlplus 1234567891011select * from test_table order by random_string offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- -------------------------------- 938145 2018-08-04 21:48:33 86 00008E7XPHROOHEPUYRC 686337 2018-08-01 23:51:45 31 00008JW9S5PXE19F4W4M 19954 2073-03-12 01:49:31 69 0000G3A2KNDLVN61WOSH 382404 3065-07-20 01:49:31 41 0000JDLZP2J8VZFOJ44J 234567 2660-10-14 01:49:31 78 000142EWU0B3GMIPA2ALElapsed: 00:00:00.33 oracle_fdw 1234567891011testdb=# select * from test_table order by random_string offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string--------+---------------------+-----------+---------------------- 938145 | 2018-08-04 21:48:33 | 86 | 00008E7XPHROOHEPUYRC 686337 | 2018-08-01 23:51:45 | 31 | 00008JW9S5PXE19F4W4M 19954 | 2073-03-12 01:49:31 | 69 | 0000G3A2KNDLVN61WOSH 382404 | 3065-07-20 01:49:31 | 41 | 0000JDLZP2J8VZFOJ44J 234567 | 2660-10-14 01:49:31 | 78 | 000142EWU0B3GMIPA2AL(5 rows)Time: 13275.162 ms (00:13.275) oracle_fdw执行时,oracle session中执行的sql psql中查看执行计划 网络流量对比 简单查询，带索引创建id索引 1create index test_id on test_table(id); 查询某条记录 sqlplus 123456SQL&gt; select * from test_table where id = 8222; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ----------------------------- 8222 2018-07-25 03:29:50 68 0VJJSTBAN6RAINSTWQAB 8222 2041-01-27 01:49:31 42 3SAYJV50LNDHURP5FU0KElapsed: 00:00:00.07 oracle_fdw 1234567testdb=# select * from test_table where id = 8222; id | inc_datetime | random_id | random_string------+---------------------+-----------+---------------------- 8222 | 2018-07-25 03:29:50 | 68 | 0VJJSTBAN6RAINSTWQAB 8222 | 2041-01-27 01:49:31 | 42 | 3SAYJV50LNDHURP5FU0K(2 rows)Time: 6.565 ms 使用orderby id获取前5行记录 sqlplus 12345678910SQL&gt; select * from test_table order by id offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ---------------------------- 1 2018-07-25 01:12:49 17 5SPF1INUG6S2L1ZSTU7R 1 2018-07-26 01:49:31 63 BIO3ZOV104VLNKZWGDZN 2 2018-07-25 01:12:50 95 HJFAWH9L7SF85YSPNDHV 2 2018-07-27 01:49:31 86 2PNXP02ZYWYYUZQFWVVN 3 2018-07-25 01:12:51 86 T3UQBBMP3O02LGO6ONPFElapsed: 00:00:00.33 oracle_fdw 12345678910testdb=# select * from test_table order by id offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string----+---------------------+-----------+---------------------- 1 | 2018-07-25 01:12:49 | 17 | 5SPF1INUG6S2L1ZSTU7R 1 | 2018-07-26 01:49:31 | 63 | BIO3ZOV104VLNKZWGDZN 2 | 2018-07-27 01:49:31 | 86 | 2PNXP02ZYWYYUZQFWVVN 2 | 2018-07-25 01:12:50 | 95 | HJFAWH9L7SF85YSPNDHV 3 | 2018-07-25 01:12:51 | 86 | T3UQBBMP3O02LGO6ONPF(5 rows)Time: 1345.988 ms (00:01.346) 创建random_string索引 1create index test_string on test_table(random_string); 查询某条记录 sqlplus 123456SQL&gt; select * from test_table where random_string='GMX0VD9WY4YPN8T4XDML'; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ------------------------------- 871 2018-07-25 01:27:19 45 GMX0VD9WY4YPN8T4XDMLElapsed: 00:00:00.01 oracle_fdw 1234567testdb=# select * from test_table where random_string='GMX0VD9WY4YPN8T4XDML'; id | inc_datetime | random_id | random_string-----+---------------------+-----------+---------------------- 871 | 2018-07-25 01:27:19 | 45 | GMX0VD9WY4YPN8T4XDML(1 row)Time: 118.376 ms 使用order by random_string获取前5条记录 sqlplus 12345678910SQL&gt; select * from test_table order by random_string offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ---------------------------------- 938145 2018-08-04 21:48:33 86 00008E7XPHROOHEPUYRC 686337 2018-08-01 23:51:45 31 00008JW9S5PXE19F4W4M 19954 2073-03-12 01:49:31 69 0000G3A2KNDLVN61WOSH 382404 3065-07-20 01:49:31 41 0000JDLZP2J8VZFOJ44J 234567 2660-10-14 01:49:31 78 000142EWU0B3GMIPA2ALElapsed: 00:00:00.36 oracle_fdw 12345678910testdb=# select * from test_table order by random_string offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string--------+---------------------+-----------+---------------------- 938145 | 2018-08-04 21:48:33 | 86 | 00008E7XPHROOHEPUYRC 686337 | 2018-08-01 23:51:45 | 31 | 00008JW9S5PXE19F4W4M 19954 | 2073-03-12 01:49:31 | 69 | 0000G3A2KNDLVN61WOSH 382404 | 3065-07-20 01:49:31 | 41 | 0000JDLZP2J8VZFOJ44J 234567 | 2660-10-14 01:49:31 | 78 | 000142EWU0B3GMIPA2AL(5 rows)Time: 12848.595 ms (00:12.849) 创建random_id,random_string复合索引 1create index test_id_string on test_table(random_id,random_string); 查询某条记录 sqlplus 123456SQL&gt; select * from test_table where random_id=74 and random_string='6PP2R3M0K4ARK411VFC3'; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ------------------------------------- 4067 2018-07-25 02:20:35 74 6PP2R3M0K4ARK411VFC3Elapsed: 00:00:00.00 oracle_fdw 1234567testdb=# select * from test_table where random_id=74 and random_string='6PP2R3M0K4ARK411VFC3'; id | inc_datetime | random_id | random_string------+---------------------+-----------+---------------------- 4067 | 2018-07-25 02:20:35 | 74 | 6PP2R3M0K4ARK411VFC3(1 row)Time: 10.488 ms orderby sqlplus 123456789SQL&gt; select * from test_table order by random_id,random_string offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ------------------------------ 231792 2018-07-27 17:36:00 0 000LENLB2SJ8M8AZKTOD 691626 2018-08-02 01:19:54 0 003GODBKGMRMZC3LTK8Z 582719 3613-12-29 01:49:31 0 0052V1U6439AGAAAW3QZ 762898 2018-08-02 21:07:46 0 0081R0VHHHJTRTPTL8RG 141007 2404-08-17 01:49:31 0 008PFJM81W6NR83WFNXQElapsed: 00:00:00.33 oracle_fdw 1234567891011testdb=# select * from test_table order by random_id,random_string offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string--------+---------------------+-----------+---------------------- 231792 | 2018-07-27 17:36:00 | 0 | 000LENLB2SJ8M8AZKTOD 691626 | 2018-08-02 01:19:54 | 0 | 003GODBKGMRMZC3LTK8Z 582719 | 3613-12-29 01:49:31 | 0 | 0052V1U6439AGAAAW3QZ 762898 | 2018-08-02 21:07:46 | 0 | 0081R0VHHHJTRTPTL8RG 141007 | 2404-08-17 01:49:31 | 0 | 008PFJM81W6NR83WFNXQ(5 rows)Time: 12857.763 ms (00:12.858) 关联查询 sqlplus 1234567select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998;USER_NAME FEE-------------------------------------------------- ----------C58IV8Z0HKYO 297.78Elapsed: 00:00:00.27 oracle_fdw 1234567testdb=# select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998; user_name | fee--------------+-------- C58IV8Z0HKYO | 297.78(1 row)Time: 139.633 ms psql的执行计划1234567891011121314testdb=# explain select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998; QUERY PLAN------------------------------------------------------------------------------------------------------------------------------------------------------------ Nested Loop (cost=20000.00..52502.50 rows=1000000 width=134) -&gt; Foreign Scan on users a (cost=10000.00..20000.00 rows=1000 width=134) Oracle query: SELECT /*f121f12a8cbc233ce7f3a1c56794af92*/ r1.\"USER_ID\", r1.\"USER_NAME\" FROM \"DBUSER\".\"USERS\" r1 WHERE (r1.\"USER_ID\" = 4999998) -&gt; Materialize (cost=10000.00..20005.00 rows=1000 width=32) -&gt; Foreign Scan on phone_fee b (cost=10000.00..20000.00 rows=1000 width=32) Oracle query: SELECT /*d1bc90927d98c625ddda179fef4df315*/ r2.\"USER_ID\", r2.\"FEE\" FROM \"DBUSER\".\"PHONE_FEE\" r2 WHERE (r2.\"USER_ID\" = 4999998)(6 rows) orderby sqlplus 1234567891011SQL&gt; select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc offset 0 rows fetch next 5 rows only; USER_ID FEE FEE_DATE---------- ---------- --------- 4999998 297.78 30-APR-15 4999997 243.36 31-MAY-15 4999996 69.79 29-JAN-12 4999992 91.03 07-OCT-17 4999992 268.93 01-FEB-15Elapsed: 00:00:00.71 oracle_fdw 1234567891011testdb=# select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc offset 0 rows fetch next 5 rows only; user_id | fee | fee_date---------+--------+------------ 4999998 | 297.78 | 2015-04-30 4999997 | 243.36 | 2015-05-31 4999996 | 69.79 | 2012-01-29 4999992 | 91.03 | 2017-10-07 4999992 | 268.93 | 2015-02-01(5 rows)Time: 27477.661 ms (00:27.478) psql的执行计划123456789101112131415testdb=# explain select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc offset 0 rows fetch next 5 rows only; QUERY PLAN-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=20016.61..20016.62 rows=5 width=36) -&gt; Sort (cost=20016.61..20019.11 rows=1000 width=36) Sort Key: users.user_id DESC -&gt; Foreign Scan (cost=10000.00..20000.00 rows=1000 width=36) Oracle query: SELECT /*c6de86645f2edcce90957e3283ade08d*/ r1.\"USER_ID\", r2.\"FEE\", r2.\"FEE_DATE\" FROM (\"DBUSER\".\"USERS\" r1 INNER JOIN \"DBUSER\".\"PHONE_FEE\" r2 ON (r1.\"USER_ID\" = r2.\"USER_ID\"))(5 rows) oracle session中执行的sql 流量情况 可见oracle_fdw实质上发送的是连接sql，拿到oracle返回的结果，再进行排序的。因此中间消耗的时间里，网络传输数据的消耗是占很大部分的。 结论oracle_fdw的查询效率主要受发送给oracle的sql查询结果集的数据量影响的，结果集越大，网络IO消耗越多，对查询的影响越大。","raw":null,"content":null,"categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://oyo-byte.github.io/tags/PostgreSQL/"},{"name":"FDW","slug":"FDW","permalink":"https://oyo-byte.github.io/tags/FDW/"},{"name":"oracle","slug":"oracle","permalink":"https://oyo-byte.github.io/tags/oracle/"}]}]}