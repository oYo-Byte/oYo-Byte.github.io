{"meta":{"title":"oYo-Byte","subtitle":null,"description":"oYo-Byte's blog","author":"oYo-Byte","url":"http://byte-cloris.com"},"pages":[],"posts":[{"title":"学习PostgreSQL的查询机制","slug":"learn_about_pg_query_processing","date":"2018-08-03T10:10:45.600Z","updated":"2018-08-06T06:31:26.351Z","comments":true,"path":"2018/08/03/learn_about_pg_query_processing/","link":"","permalink":"http://byte-cloris.com/2018/08/03/learn_about_pg_query_processing/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"学习PostgreSQL的FDW","slug":"learn_about_pgfdw","date":"2018-08-03T07:52:42.563Z","updated":"2018-08-06T09:33:43.003Z","comments":true,"path":"2018/08/03/learn_about_pgfdw/","link":"","permalink":"http://byte-cloris.com/2018/08/03/learn_about_pgfdw/","excerpt":"","text":"实现一个FDW的核心是实现一组回调函数，有了这些回调函数的帮助, 在查询外部表对象的执行过程中就可以将运行逻辑切换至自定义的扩展代码中, 进而遵照PG的内部机制实现对外部数据源的访问。 目前PostgreSQL11 beta2，提供的FDW回调函数接口有39个。FDW的实现者需要根据外部数据源自身的能力（比如是否支持写操作，以及是否支持在外部数据源端执行join操作等等）对这些接口有选择地予以实现。 这些接口中, 最核心的接口有7个。无论外部数据源自身能力如何, 这7个接口是实现通过外部表对象访问该数据源的必须接口。它们的接口定义如下: 12345678910111213typedef void (*GetForeignRelSize_function) (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);typedef void (*GetForeignPaths_function) (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);typedef ForeignScan *(*GetForeignPlan_function) (PlannerInfo *root, RelOptInfo *baserel,Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan);typedef void (*BeginForeignScan_function) (ForeignScanState *node, int eflags);typedef TupleTableSlot *(*IterateForeignScan_function) (ForeignScanState *node);typedef void (*ReScanForeignScan_function) (ForeignScanState *node);typedef void (*EndForeignScan_function) (ForeignScanState *node); 在PG中，查询语句经过以下5个子系统处理： Parser用于将文本式的SQL命令转换成解析树 Analyzer/Analyser用于执行解析树的语义分析并生成查询树 Rewriter重写器用于根据规则系统中已存在的规则转换查询树 Planner规划器生成可以从查询树中最有效地执行的计划树 Executor执行器通过按计划树创建的顺序访问表和索引来执行查询 可以整合成三个大阶段： Parser: 包含对SQL的语法解析，语义校验，查询重写 Optimizer：生成查询计划 Executor：按照火山模型执行查询计划的算子并向上返回数据 PG的FDW所需的7个回调函数主要是在Optimizer和Executor阶段进行“介入”: 这7个回调函数详细的调用时间以及作用： 回调函数 在PG中的调用时机 作用 详细描述 GetForeignRelSize 优化器生成访问路径的过程中对外部表估算访问代价时 提供外部表对于计算访问代价所需的基础数据，如表的元组数以及元组的平均长度,并将这些数据保存在输入参数baserel的字段”rows”以及”width”中 void GetForeignRelSize (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid); root是规划器的关于该查询的全局信息；baserel是规划器的关于该表的信息；foreigntableid是外部表在pg_class中的 OID （foreigntableid可以从规划器的数据结构中获得，但是为了减少工作量，这里直接显式地将它传递给函数）；这个函数应该更新baserel-&gt;rows为表扫描根据限制条件完成了过滤后将返回的预期行数。baserel-&gt;rows的初始值只是一个常数的默认估计值，应该尽可能把它替换掉。如果该函数能够计算出一个平均结果行宽度的更好的估计值，该函数也可能选择更新baserel-&gt;width。 GetForeignPaths 生成对外部表的访问路径时 生成对目标外部表的访问路径(通过PG中的接口createforeignscanpath()生成) void GetForeignPaths (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid);参数和GetForeignRelSize相同；这个函数必须为外部表上的扫描生成至少一个访问路径（ForeignPath节点），并且必须调用add_path把每一个这样的路径加入到baserel-&gt;pathlist中。我们推荐使用create_foreignscan_path来建立ForeignPath节点。该函数可以生成多个访问路径，例如一个具有合法pathkeys的路径表示一个预排序好的结果。每一个访问路径必须包含代价估计，并且能包含任何FDW的私有信息，这种信息被用来标识想要使用的指定扫描方法。 GetForeignPlan 优化器生成扫描外部表的查询计划节点时 生成访问目标外部表的ForeignScan计划节点(通过PG中的接口make_foreignscan()) ForeignScan * GetForeignPlan (PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid, ForeignPath *best_path, List *tlist, List *scan_clauses, Plan *outer_plan);参数和GetForeignRelSize的一样，外加选中的ForeignPath（在前面由GetForeignPaths、GetForeignJoinPaths或者GetForeignUpperPaths产生）、被计划节点发出的目标列表以及计划节点强制的限制子句以及被RecheckForeignScan执行的复查所使用的ForeignScan的外子计划（如果该路径是用于一个连接而非基本关系，则foreigntableid是InvalidOid）；这个函数必须创建并返回一个ForeignScan计划节点，推荐使用make_foreignscan来建立ForeignScan节点。 BeginForeignScan 执行器即将开始执行ForeignScan算子，进行该算子相关的初始化时 获取执行ForeignScan算子所需的信息，并将它们组织并保存在ForeignScanState中 void BeginForeignScan (ForeignScanState *node, int eflags);它应该执行任何在扫描能够开始之前需要完成的初始化工作，但是并不开始执行真正的扫描（会在第一次调用IterateForeignScan时完成）。ForeignScanState节点已经被创建好了，但是它的fdw_state属性仍然为 NULL。关于要被扫描的表的信息可以通过ForeignScanState节点访问（特殊地，从底层的ForeignScan计划节点，它包含任何由GetForeignPlan提供的FDW私有信息）。eflags包含描述执行器对该计划节点操作模式的标志位。注意当(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)为真时，这个函数不应该执行任何外部可见的动作；它应当只做最少的事情来创建对ExplainForeignScan 和EndForeignScan有效的节点状态 IterateForeignScan 执行ForeignScan算子过程中需要获取下一元组时 读取外部数据源的一行数据，并将它组织为PG中的Tuple(即TupleTableSlot). 当该回调函数返回一个空的TupleTableSlot结构时, 迭代器停止迭代 TupleTableSlot * IterateForeignScan (ForeignScanState *node);从外部源获得一行，将它放在一个元组表槽中返回（节点的ScanTupleSlot应当被用于此目的）。如果没有更多的行可用则返回 NULL。元组表槽设施允许一个物理的或者虚拟的元组被返回；在大部分情况下出于性能的考虑会倾向于选择后者。注意这是在一个短期存在的内存上下文中被调用的，该内存上下文会在调用之间被重置。如果需要长期存在的存储，需要在BeginForeignScan中创建内存上下文，或者使用节点的EState中的es_query_cxt。如果提供了fdw_scan_tlist目标列表，被返回的行必须匹配它，如果没有提供则它们必须匹配被扫描的外部表的行类型。如果选择优化掉不需要的列，你应该在那些列的位置上插入控制或者生成一个忽略了那些列的fdw_scan_tlist列表。注意PostgreSQL的执行器并不在乎被返回的行是否违背了定义在该外部表上的任何约束 — 但是规划器会在乎这一点，并且如果在外部表中有可见行不满足一个约束，规划器可能会错误地优化查询。如果当用户已经声明一个约束应该为真时它却被违背，最合适的处理可能是产生一个错误（就像在数据类型失配的情况下所作的那样） ReScanForeignScan 执行Nested Loop过程中需要重置Inner Scan时(即Outter Scan需要向前推进一行时) 将外部数据源的读取位置重置回最初的起始位置 void ReScanForeignScan (ForeignScanState *node);注意扫描所依赖的任何参数可能已经改变了值，因此新扫描不一定会返回完全相同的行。 EndForeignScan ForeignScan算子执行完成时 释放整个ForeignScan算子执行过程中占用的外部资源或FDW中的资源 void EndForeignScan (ForeignScanState *node);通常释放palloc过的内存并不重要，但是打开的文件和到远程服务器的连接等应该被清理。 以上是必须实现的扫描相关的回调函数 参考： https://xiaowing.github.io/post/20180513_write_pgfdw_in_golang_part02/","raw":null,"content":null,"categories":[],"tags":[]},{"title":"解读C语言声明","slug":"解读C语言声明","date":"2018-07-26T03:18:23.922Z","updated":"2018-08-02T16:51:28.267Z","comments":true,"path":"2018/07/26/解读C语言声明/","link":"","permalink":"http://byte-cloris.com/2018/07/26/解读C语言声明/","excerpt":"","text":"C语言所有复杂的指针声明，都是由各种声明嵌套构成的。如何解读复杂指针声明呢？ 右左法则（既著名又常用的方法 ） 右左法则英文原文： The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed. 翻译如下： 右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。 这时就会有个疑惑：怎样判断那个括号是最里面的呢？ 因此需要对这个法则进行修改，结合《C专家编程》里提到的分析方法，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。 分析C语言的声明步骤： 第1步：从左至右，找到第一个未定义的标识符。 第2步：查看标识符右边的符号，并确定是一个数组还是函数。 第3步：查看左边的符号。 第3步a：如果是左括号则将处理过的部分结合到一起直到遇到右括号作为标识符返回第2步。 第3步b：如果是const，volatile，*其中之一则继续向左直到不是这三个符号之一。 第4步：剩下的符号构成声明的基本类型。 感觉还是有点晕？ 结合例子说明： 1char (*(*x[3])())[5]; 第1步：从左到右找到第一个标识符x。 第2步：查看标识符右边的符号是[，说明x是一个具有3个元素的数组。 第3步：查看左边的符号是*，转至第3步b。 第3步b：说明数组中的元素都是指针，向左就是左括号了，将这个左括号结合到对应的右括号（也就是(*x[3])）作为新的标识符返回第2步 。 第2步：查看右边的符号是(，说明指针是指向参数列表为空的函数的指针。 查看左边的符号，是*, 转至第3步b。 说明函数的返回值是指针，向左是左括号，将这个左括号结合到对应的右括号（也就是(*(*x[3])())）作为新的标识符返回第2步。 第2步：查看右边的符号是[，所以是指向具有五个元素的数组的指针。 第3步：查看左边的括号，既不是a情况，也不是b情况，跳至第4步。 第4步：数组的类型为char。 所以以上的声明表示的是x是一个具有3个元素的数组，数组的每个元素都是一个指向函数的指针，函数的参数列表为空，返回值是指向一个具有5个元素的指针，元素的类型为char。 来个程序验证一下12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;char *func()&#123; char arr[5] = &#123;'1', '2', '3','4','5'&#125;; return arr;&#125;int main()&#123; char (*(*x[3])())[5]; // x是一个长度为3的数组，元素是一个函数指针，函数的返回值是指向一个长度为5的char型数组指针。 x[0] = &amp;func; printf(\"x的总长度：%d \\n\",sizeof(x)); printf(\"x元素的长度：%d \\n\",sizeof(x[0])); printf(\"函数指针的长度：%d \\n\",sizeof(void *)); printf(\"x的元素个数：%d \\n\",sizeof(x)/sizeof(x[0])); char (*c)[5] = (x[0])();//c是一个指向长度为5的char型数组的指针 printf(\"c的总长度：%d \\n\",sizeof(*c)); printf(\"c元素的长度：%d \\n\",sizeof((*c)[0])); printf(\"char型的长度：%d \\n\",sizeof(char)); printf(\"c的第4个元素是：%c \\n\",(*c)[3]); printf(\"整体调用，第4个元素是：%c \\n\",(*(x[0])())[3]); return 0;&#125; 运行结果：123456789x的总长度：24x元素的长度：8函数指针的长度：8x的元素个数：3c的总长度：5c元素的长度：1chart性的长度：1c的第4个元素是：4整体调用，结果的第4个元素是：4 Try: 11. char *(*c[10])(int **p) Clockwise/Spiral Rule（顺时针/螺旋法则） 三步： 从未定义标识符开始，以顺时针方向移动，当遇到以下元素时，用相应的语言陈述替换它们： ​ [X] or [] =&gt; Array X size of… or Array undefined size of… ​ (type1, type2) =&gt; function passing type1 and type2 returning… ​ * =&gt; pointer(s) to… 继续以上步骤，直至覆盖所有的字符。 首先解决括号中的内容。 例1： 1char *str[10]; 1234567 +-------+ | +-+ | | ^ | |char *str[10]; ^ ^ | | | +---+ | +-----------+ str是什么？ “str是一个…… 从str开始以顺时针方向移动，遇到[，这意味着是一个数组 “str是一个长度为10的数组，元素是…… 继续移动，遇到*,说明是指针 “str是一个长度为10的数组，元素是指向……的指针 继续遇到了;，然后继续移动，遇到char “str是一个长度为10的数组，元素是指向char的指针” 遍历完所有字符，解析完毕 以上的char (*(*x[3])())[5];亦可这样去处理123456789 +----------+ | +-----+ | | |++ | | | |^| | |char (*(*x[3])())[5]; ^ ^ ^ | | | | | +-+ | | | +-------+ | +---------------+ x是什么？“x是一个…… 从x开始以顺时针方向移动，遇到[，这意味着是一个数组“x是一个长度为3的数组，元素是…… 继续移动，遇到*,说明是指针“x是一个长度为3的数组，元素是指向……的指针 继续遇到(,说明是函数“x是一个长度为3的数组，元素是指向函数的指针，函数是…… 继续遇到*，说明是指针“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向……的指针 继续遇到[，说明是数组“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向长度为5的……类型元素的数组的指针 继续遇到char,说明元素是char型“x是一个长度为3的数组，元素是指向函数的指针，函数是参数列表为空，返回值是指向长度为5的char类型元素的数组的指针” 遍历完毕 Try: 122. char *(*fp)( int, float *);3. void (*signal(int, void (*fp)(int)))(int); Answer： c是一个具有10个元素的数组，数组的元素都是函数指针，其所指向的函数是接受一个指向整型指针的指针，返回值是指向char的指针。 123456789 +-----------------+ | +------+ +-+| | |++ | |++| | |^| | |^||char *(*c[10])(int **p); ^ ^ ^ | | ^^ || | | +-+ | |+-+| | +--------+ +--+| +--------------------+ fp是一个函数指针，该函数接受一个整型和一个浮点型指针入参，返回值是指向char的指针。 123456789 +--------------------+ | +---+ | | |+-+| | | |^ || |char *(*fp)( int, float *); ^ ^ ^ || | | | +--+| | | +-----+ | +------------------------+ signal是一个函数，该函数值一个接受一个整型和一个函数指针（该函数是入参是整型，返回值为空void），返回值是指向一个入参是整型，返回值是空void的函数指针。 123456789 +-----------------------------+ | +---+ | | +---+ |+-+| | | ^ | |^ || |void (*signal(int, void (*fp)(int)))(int); ^ ^ | ^ ^ || | | +------+ | +--+| | | +--------+ | +----------------------------------+ 参考： C语言复杂声明解析 c语言声明的分析方法 The Clockwise/Spiral Rule","raw":null,"content":null,"categories":[],"tags":[]},{"title":"PostgreSQL使用oracle_fdw与Oracle查询性能对比","slug":"PostgreSQL使用oracle_fdw与Oracle查询性能对比","date":"2018-07-25T03:29:52.892Z","updated":"2018-08-02T07:00:33.983Z","comments":true,"path":"2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/","link":"","permalink":"http://byte-cloris.com/2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/","excerpt":"","text":"在PostgreSQL中使用oracle_fdw安装oracle_fdw插件 安装前要求： 全部功能要求PostgreSQL9.3及以上 Oracle client要求10.1以上 确保PostgreSQL配置了--without-ldap 确保pg_config在PATH中(用 pg_config --pgxs测试) 设置了ORACLE_HOME环境变量 下载oracle_fdw源代码,并解压到某个目录下，进入文件目录，执行： 12$ make$ make install 安装完毕后，使用psql连接到PostgreSQL；1$ psql -d testdb; 使用PostgreSQL的超级用户配置oralce_fdw: 123testdb=# create extension oracle_fdw;testdb=# create server oracle_121_56 foreign data wrapper oracle_fdw options (dbserver '//192.168.121.56:1521/orcl');testdb=# create user mapping for public server oracle_121_56 options (user 'dbuser' password 'test'); 简单查询，无索引生成测试数据，创建一个表，并同时添加1百万条数据 1create table test_table as select rownum as id,to_char(sysdate + rownum/24/3600, 'yyyy-mm-dd hh24:mi:ss') as inc_datetime,trunc(dbms_random.value(0, 100)) as random_id,dbms_random.string('x', 20) random_string from dual connect by level &lt;= 1000000; 创建完表后，在原来表的基础上追加记录12insert into test_table (ID, INC_DATETIME,RANDOM_ID,RANDOM_STRING) select rownum as id, to_char(sysdate + rownum, 'yyyy-mm-dd hh24:mi:ss') as inc_datetime,trunc(dbms_random.value(0, 100)) as random_id, dbms_random.string('x', 20) random_string from dual connect by level &lt;= 1000000;commit; 上面SQL是利用了Oracle数据库语法的几个实用小技巧实现的: 利用Oracle特有的“connect by”树形连接语法生成测试记录，“level &lt;= 10”表示要生成10记录； 利用rownum虚拟列生成递增的整数数据； 利用sysdate函数加一些简单运算来生成日期数据，本例中是每条记录的时间加1秒； 利用dbms_random.value函数生成随机的数值型数据，本例中是生成0到100之间的随机整数； 利用dbms_random.string函数生成随机的字符型数据，本例中是生成长度为20的随机字符串，字符串中可以包括字符或数字。 to_char(sysdate + rownum, ‘yyyy-mm-dd hh24:mi:ss’) 这里是转换为字符串，如果该字段的类型为TimeStamp时间戳，那这里可以改写一下方法，转换为时间戳 to_timestamp(sysdate + rownum, ‘yyyy-mm-dd hh24:mi:ss’) PostgreSQL 创建相应的外部表 1testdb=# create foreign table test_table(id int, inc_datetime varchar(19), random_id int, random_string varchar(4000)) server oracle_121_56 options (schema 'DBUSER', table 'TEST_TABLE'); 查询表的行数 sqlplus 1$ sqlplus dbuser/test@//192.168.121.56:1521/orcl 12345SQL&gt; select count(*) from test_table; COUNT(*)----------2000000Elapsed: 00:00:00.13 oracle_fdw 123456testdb=# select count(*) from test_table;count---------2000000(1 row)Time: 5264.299 ms (00:05.264) 查看oracle session中真正执行的sql语句，红框为oracle_fdw执行时，oracle session中执行的sql： 在psql中查看select count(*) from test_table;的执行计划： 可见oracle处理的sql即是查询计划中的oracle query后面的sql 查看网络流量oracle_fdw的网络流量明显比sqlplus要高出很多。 查询某条记录 sqlplus 1234567SQL&gt; select * from test_table where id= 50; ID INC_DATETIME RANDOM_ID RANDOM_STRING-------- -------------------- ------------ ----------------------------- 50 2018-07-25 01:13:38 21 2VMPGE0K6Y293T9WRT7G 50 2018-09-13 01:49:31 51 RGUV1BJJNSTNXDMXMVRLElapsed: 00:00:00.05 oracle_fdw 12345678testdb=# select * from test_table where id= 50; id | inc_datetime | random_id | random_string----+---------------------+-----------+---------------------- 50 | 2018-07-25 01:13:38 | 21 | 2VMPGE0K6Y293T9WRT7G 50 | 2018-09-13 01:49:31 | 51 | RGUV1BJJNSTNXDMXMVRL(2 rows)Time: 56.811 ms 使用orderby id获取前5行记录 sqlplus 1234567891011SQL&gt; select * from test_table order by id offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING-------- ------------------- ---------- ---------------------- 1 2018-07-25 01:12:49 17 5SPF1INUG6S2L1ZSTU7R 1 2018-07-26 01:49:31 63 BIO3ZOV104VLNKZWGDZN 2 2018-07-25 01:12:50 95 HJFAWH9L7SF85YSPNDHV 2 2018-07-27 01:49:31 86 2PNXP02ZYWYYUZQFWVVN 3 2018-07-25 01:12:51 86 T3UQBBMP3O02LGO6ONPFElapsed: 00:00:00.32 oracle_fdw 1234567891011testdb=# select * from test_table order by id offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string----+---------------------+-----------+---------------------- 1 | 2018-07-25 01:12:49 | 17 | 5SPF1INUG6S2L1ZSTU7R 1 | 2018-07-26 01:49:31 | 63 | BIO3ZOV104VLNKZWGDZN 2 | 2018-07-27 01:49:31 | 86 | 2PNXP02ZYWYYUZQFWVVN 2 | 2018-07-25 01:12:50 | 95 | HJFAWH9L7SF85YSPNDHV 3 | 2018-07-25 01:12:51 | 86 | T3UQBBMP3O02LGO6ONPF(5 rows)Time: 1169.874 ms (00:01.170) 使用orderby random_string获取前5行记录 sqlplus 1234567891011select * from test_table order by random_string offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- -------------------------------- 938145 2018-08-04 21:48:33 86 00008E7XPHROOHEPUYRC 686337 2018-08-01 23:51:45 31 00008JW9S5PXE19F4W4M 19954 2073-03-12 01:49:31 69 0000G3A2KNDLVN61WOSH 382404 3065-07-20 01:49:31 41 0000JDLZP2J8VZFOJ44J 234567 2660-10-14 01:49:31 78 000142EWU0B3GMIPA2ALElapsed: 00:00:00.33 oracle_fdw 1234567891011testdb=# select * from test_table order by random_string offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string--------+---------------------+-----------+---------------------- 938145 | 2018-08-04 21:48:33 | 86 | 00008E7XPHROOHEPUYRC 686337 | 2018-08-01 23:51:45 | 31 | 00008JW9S5PXE19F4W4M 19954 | 2073-03-12 01:49:31 | 69 | 0000G3A2KNDLVN61WOSH 382404 | 3065-07-20 01:49:31 | 41 | 0000JDLZP2J8VZFOJ44J 234567 | 2660-10-14 01:49:31 | 78 | 000142EWU0B3GMIPA2AL(5 rows)Time: 13275.162 ms (00:13.275) oracle_fdw执行时,oracle session中执行的sql psql中查看执行计划 网络流量对比 简单查询，带索引创建id索引 1create index test_id on test_table(id); 查询某条记录 sqlplus 123456SQL&gt; select * from test_table where id = 8222; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ----------------------------- 8222 2018-07-25 03:29:50 68 0VJJSTBAN6RAINSTWQAB 8222 2041-01-27 01:49:31 42 3SAYJV50LNDHURP5FU0KElapsed: 00:00:00.07 oracle_fdw 1234567testdb=# select * from test_table where id = 8222; id | inc_datetime | random_id | random_string------+---------------------+-----------+---------------------- 8222 | 2018-07-25 03:29:50 | 68 | 0VJJSTBAN6RAINSTWQAB 8222 | 2041-01-27 01:49:31 | 42 | 3SAYJV50LNDHURP5FU0K(2 rows)Time: 6.565 ms 使用orderby id获取前5行记录 sqlplus 12345678910SQL&gt; select * from test_table order by id offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ---------------------------- 1 2018-07-25 01:12:49 17 5SPF1INUG6S2L1ZSTU7R 1 2018-07-26 01:49:31 63 BIO3ZOV104VLNKZWGDZN 2 2018-07-25 01:12:50 95 HJFAWH9L7SF85YSPNDHV 2 2018-07-27 01:49:31 86 2PNXP02ZYWYYUZQFWVVN 3 2018-07-25 01:12:51 86 T3UQBBMP3O02LGO6ONPFElapsed: 00:00:00.33 oracle_fdw 12345678910testdb=# select * from test_table order by id offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string----+---------------------+-----------+---------------------- 1 | 2018-07-25 01:12:49 | 17 | 5SPF1INUG6S2L1ZSTU7R 1 | 2018-07-26 01:49:31 | 63 | BIO3ZOV104VLNKZWGDZN 2 | 2018-07-27 01:49:31 | 86 | 2PNXP02ZYWYYUZQFWVVN 2 | 2018-07-25 01:12:50 | 95 | HJFAWH9L7SF85YSPNDHV 3 | 2018-07-25 01:12:51 | 86 | T3UQBBMP3O02LGO6ONPF(5 rows)Time: 1345.988 ms (00:01.346) 创建random_string索引 1create index test_string on test_table(random_string); 查询某条记录 sqlplus 123456SQL&gt; select * from test_table where random_string='GMX0VD9WY4YPN8T4XDML'; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ------------------------------- 871 2018-07-25 01:27:19 45 GMX0VD9WY4YPN8T4XDMLElapsed: 00:00:00.01 oracle_fdw 1234567testdb=# select * from test_table where random_string='GMX0VD9WY4YPN8T4XDML'; id | inc_datetime | random_id | random_string-----+---------------------+-----------+---------------------- 871 | 2018-07-25 01:27:19 | 45 | GMX0VD9WY4YPN8T4XDML(1 row)Time: 118.376 ms 使用order by random_string获取前5条记录 sqlplus 12345678910SQL&gt; select * from test_table order by random_string offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ---------------------------------- 938145 2018-08-04 21:48:33 86 00008E7XPHROOHEPUYRC 686337 2018-08-01 23:51:45 31 00008JW9S5PXE19F4W4M 19954 2073-03-12 01:49:31 69 0000G3A2KNDLVN61WOSH 382404 3065-07-20 01:49:31 41 0000JDLZP2J8VZFOJ44J 234567 2660-10-14 01:49:31 78 000142EWU0B3GMIPA2ALElapsed: 00:00:00.36 oracle_fdw 12345678910testdb=# select * from test_table order by random_string offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string--------+---------------------+-----------+---------------------- 938145 | 2018-08-04 21:48:33 | 86 | 00008E7XPHROOHEPUYRC 686337 | 2018-08-01 23:51:45 | 31 | 00008JW9S5PXE19F4W4M 19954 | 2073-03-12 01:49:31 | 69 | 0000G3A2KNDLVN61WOSH 382404 | 3065-07-20 01:49:31 | 41 | 0000JDLZP2J8VZFOJ44J 234567 | 2660-10-14 01:49:31 | 78 | 000142EWU0B3GMIPA2AL(5 rows)Time: 12848.595 ms (00:12.849) 创建random_id,random_string复合索引 1create index test_id_string on test_table(random_id,random_string); 查询某条记录 sqlplus 123456SQL&gt; select * from test_table where random_id=74 and random_string='6PP2R3M0K4ARK411VFC3'; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ------------------------------------- 4067 2018-07-25 02:20:35 74 6PP2R3M0K4ARK411VFC3Elapsed: 00:00:00.00 oracle_fdw 1234567testdb=# select * from test_table where random_id=74 and random_string='6PP2R3M0K4ARK411VFC3'; id | inc_datetime | random_id | random_string------+---------------------+-----------+---------------------- 4067 | 2018-07-25 02:20:35 | 74 | 6PP2R3M0K4ARK411VFC3(1 row)Time: 10.488 ms orderby sqlplus 123456789SQL&gt; select * from test_table order by random_id,random_string offset 0 rows fetch next 5 rows only; ID INC_DATETIME RANDOM_ID RANDOM_STRING---------- ------------------- ---------- ------------------------------ 231792 2018-07-27 17:36:00 0 000LENLB2SJ8M8AZKTOD 691626 2018-08-02 01:19:54 0 003GODBKGMRMZC3LTK8Z 582719 3613-12-29 01:49:31 0 0052V1U6439AGAAAW3QZ 762898 2018-08-02 21:07:46 0 0081R0VHHHJTRTPTL8RG 141007 2404-08-17 01:49:31 0 008PFJM81W6NR83WFNXQElapsed: 00:00:00.33 oracle_fdw 1234567891011testdb=# select * from test_table order by random_id,random_string offset 0 rows fetch next 5 rows only; id | inc_datetime | random_id | random_string--------+---------------------+-----------+---------------------- 231792 | 2018-07-27 17:36:00 | 0 | 000LENLB2SJ8M8AZKTOD 691626 | 2018-08-02 01:19:54 | 0 | 003GODBKGMRMZC3LTK8Z 582719 | 3613-12-29 01:49:31 | 0 | 0052V1U6439AGAAAW3QZ 762898 | 2018-08-02 21:07:46 | 0 | 0081R0VHHHJTRTPTL8RG 141007 | 2404-08-17 01:49:31 | 0 | 008PFJM81W6NR83WFNXQ(5 rows)Time: 12857.763 ms (00:12.858) 关联查询 sqlplus 1234567select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998;USER_NAME FEE-------------------------------------------------- ----------C58IV8Z0HKYO 297.78Elapsed: 00:00:00.27 oracle_fdw 1234567testdb=# select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998; user_name | fee--------------+-------- C58IV8Z0HKYO | 297.78(1 row)Time: 139.633 ms psql的执行计划1234567891011121314testdb=# explain select a.user_name,b.fee from users a,phone_fee b where a.user_id=b.user_id and a.user_id=4999998; QUERY PLAN------------------------------------------------------------------------------------------------------------------------------------------------------------ Nested Loop (cost=20000.00..52502.50 rows=1000000 width=134) -&gt; Foreign Scan on users a (cost=10000.00..20000.00 rows=1000 width=134) Oracle query: SELECT /*f121f12a8cbc233ce7f3a1c56794af92*/ r1.\"USER_ID\", r1.\"USER_NAME\" FROM \"DBUSER\".\"USERS\" r1 WHERE (r1.\"USER_ID\" = 4999998) -&gt; Materialize (cost=10000.00..20005.00 rows=1000 width=32) -&gt; Foreign Scan on phone_fee b (cost=10000.00..20000.00 rows=1000 width=32) Oracle query: SELECT /*d1bc90927d98c625ddda179fef4df315*/ r2.\"USER_ID\", r2.\"FEE\" FROM \"DBUSER\".\"PHONE_FEE\" r2 WHERE (r2.\"USER_ID\" = 4999998)(6 rows) orderby sqlplus 1234567891011SQL&gt; select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc offset 0 rows fetch next 5 rows only; USER_ID FEE FEE_DATE---------- ---------- --------- 4999998 297.78 30-APR-15 4999997 243.36 31-MAY-15 4999996 69.79 29-JAN-12 4999992 91.03 07-OCT-17 4999992 268.93 01-FEB-15Elapsed: 00:00:00.71 oracle_fdw 1234567891011testdb=# select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc offset 0 rows fetch next 5 rows only; user_id | fee | fee_date---------+--------+------------ 4999998 | 297.78 | 2015-04-30 4999997 | 243.36 | 2015-05-31 4999996 | 69.79 | 2012-01-29 4999992 | 91.03 | 2017-10-07 4999992 | 268.93 | 2015-02-01(5 rows)Time: 27477.661 ms (00:27.478) psql的执行计划123456789101112131415testdb=# explain select users.user_id,phone_fee.fee,phone_fee.fee_date from users ,phone_fee where users.user_id=phone_fee.user_id order by users.user_id desc offset 0 rows fetch next 5 rows only; QUERY PLAN-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=20016.61..20016.62 rows=5 width=36) -&gt; Sort (cost=20016.61..20019.11 rows=1000 width=36) Sort Key: users.user_id DESC -&gt; Foreign Scan (cost=10000.00..20000.00 rows=1000 width=36) Oracle query: SELECT /*c6de86645f2edcce90957e3283ade08d*/ r1.\"USER_ID\", r2.\"FEE\", r2.\"FEE_DATE\" FROM (\"DBUSER\".\"USERS\" r1 INNER JOIN \"DBUSER\".\"PHONE_FEE\" r2 ON (r1.\"USER_ID\" = r2.\"USER_ID\"))(5 rows) oracle session中执行的sql 流量情况 可见oracle_fdw实质上发送的是连接sql，拿到oracle返回的结果，再进行排序的。因此中间消耗的时间里，网络传输数据的消耗是占很大部分的。 结论oracle_fdw的查询效率主要受发送给oracle的sql查询结果集的数据量影响的，结果集越大，网络IO消耗越多，对查询的影响越大。","raw":null,"content":null,"categories":[],"tags":[]}]}