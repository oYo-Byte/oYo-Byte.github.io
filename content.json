{"meta":{"title":"oYo","subtitle":null,"description":null,"author":"oYo-Byte","url":"http://byte-cloris.com"},"pages":[],"posts":[{"title":"编写PostgreSQL的外部数据包装器","slug":"PostgreSQL-编写FDW","date":"2018-07-25T03:38:05.789Z","updated":"2018-07-25T03:40:09.029Z","comments":true,"path":"2018/07/25/PostgreSQL-编写FDW/","link":"","permalink":"http://byte-cloris.com/2018/07/25/PostgreSQL-编写FDW/","excerpt":"","text":"外部数据包装函数 FDW作者需要实现处理器函数，并且可以有选择地实现一个验证器函数。两个函数都必须被用一种编译语言（如C）编写。 处理器函数简单地返回一个函数指针结构给回调函数，回调函数将被规划器、执行器和多种维护命令调用。编写一个FDW的大部分工作量都在实现这些回调函数上。处理器函数必须被注册在PostgreSQL中，并且注册为不需要参数并且返回特殊的伪类型fdw_handler。回调函数则是普通的 C 函数并且对于 SQL 层是不可见的或者不可调用的。 验证器函数负责验证CREATE和ALTER命令中对它的外部数据包装器给出的选项，以及使用该包装器的外部服务器、用户映射和外部表。验证器函数必须被注册为要求两个参数：一个包含需要被验证的选项的文本数组，以及一个表示与这些选项相关联的对象类型的OID（以该对象可能被存储的系统目录的OID的形式， 可以是ForeignDataWrapperRelationId、ForeignServerRelationId、UserMappingRelationId、 或ForeignTableRelationId）。如果没有提供验证器函数，在对象创建或修改时选项不会被检查。 外部数据包装器回调例程外部数据包装器辅助函数外部数据包装器查询规划外部数据包装器中行锁定","raw":null,"content":null,"categories":[],"tags":[]},{"title":"PostgreSQL使用oracle_fdw与Oracle查询性能对比","slug":"PostgreSQL使用oracle_fdw与Oracle查询性能对比","date":"2018-07-25T03:29:52.000Z","updated":"2018-07-25T03:40:02.901Z","comments":true,"path":"2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/","link":"","permalink":"http://byte-cloris.com/2018/07/25/PostgreSQL使用oracle_fdw与Oracle查询性能对比/","excerpt":"","text":"在PostgreSQL中使用oracle_fdw安装oracle_fdw插件 安装前要求： 全部功能要求PostgreSQL9.3及以上 Oracle client要求10.1以上 确保PostgreSQL配置了--without-ldap 确保pg_config在PATH中(用 pg_config --pgxs测试) 设置了ORACLE_HOME环境变量 下载oracle_fdw源代码,并解压到某个目录下，进入文件目录，执行： $ make$ make install 安装完毕后，使用psql连接到PostgreSQL； $ psql -d testdb; 使用PostgreSQL的超级用户配置oralce_fdw: testdb=# create extension oracle_fdw;testdb=# create server oracle_121_56 foreign data wrapper oracle_fdw options (dbserver ‘//192.168.121.56:1521/orcl’);testdb=# create user mapping for public server oracle_121_56 options (user ‘dbuser’ password ‘test’); 简单查询，无索引 生成测试数据，创建一个表，并同时添加1百万条数据 create table test_noindex as select rownum as id,to_char(sysdate + rownum/24/3600, &apos;yyyy-mm-dd hh24:mi:ss&apos;) as inc_datetime,trunc(dbms_random.value(0, 100)) as random_id,dbms_random.string(&apos;x&apos;, 20) random_string from dual connect by level &lt;= 1000000; 创建完表后，在原来表的基础上追加记录 insert into test_noindex (ID, INC_DATETIME,RANDOM_ID,RANDOM_STRING) select rownum as id, to_char(sysdate + rownum, &apos;yyyy-mm-dd hh24:mi:ss&apos;) as inc_datetime,trunc(dbms_random.value(0, 100)) as random_id, dbms_random.string(&apos;x&apos;, 20) random_string from dual connect by level &lt;= 1000000; commit; 上面SQL是利用了Oracle数据库语法的几个实用小技巧实现的: 1. 利用Oracle特有的“connect by”树形连接语法生成测试记录，“level &lt;= 10”表示要生成10记录； 2. 利用rownum虚拟列生成递增的整数数据； 3. 利用sysdate函数加一些简单运算来生成日期数据，本例中是每条记录的时间加1秒； 4. 利用dbms_random.value函数生成随机的数值型数据，本例中是生成0到100之间的随机整数； 5. 利用dbms_random.string函数生成随机的字符型数据，本例中是生成长度为20的随机字符串，字符串中可以包括字符或数字。 6. to_char(sysdate + rownum, &apos;yyyy-mm-dd hh24:mi:ss&apos;) 这里是转换为字符串，如果该字段的类型为TimeStamp时间戳，那这里可以改写一下方法，转换为时间戳 to_timestamp(sysdate + rownum, &apos;yyyy-mm-dd hh24:mi:ss&apos;) PostgreSQL 创建相应的外部表 testdb=# create foreign table test_noindex(id int, inc_datetime varchar(19), random_id int, random_string varchar(4000)) server oracle_121_56 options (schema &apos;DBUSER&apos;, table &apos;TEST_NOINDEX&apos;); 查询表的行数 sqlplus $ sqlplus dbuser/test@//192.168.121.56:1521/orcl SQL&gt; select count(*) from test_noindex; COUNT(*) ---------- 2000000 Elapsed: 00:00:00.13 oralce_fdw testdb=# select count(*) from test_noindex; count --------- 2000000 (1 row) Time: 5264.299 ms (00:05.264) 查询某条记录 sqlplus","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-07-25T03:27:29.778Z","updated":"2018-07-25T03:27:29.779Z","comments":true,"path":"2018/07/25/hello-world/","link":"","permalink":"http://byte-cloris.com/2018/07/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}